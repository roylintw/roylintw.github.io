[{"categories":["心得"],"contents":"今天早上跟沛彤去西門吃早午餐， 然後看甲狀腺門診， 等到下午1點半去衡觀診所退費\n","permalink":"https://roylintw.github.io/blog/diary/20250416/","tags":["日記"],"title":"20250416(三)西門一日遊"},{"categories":["演算法"],"contents":"氣泡排序法（Bubble Sort）是一種簡單的排序演算法，用於對列表或數組中的元素進行排序。該演算法的基本原理是從列表的開頭開始，兩兩比較相鄰的元素，並在必要時進行交換。這個過程重複多次，直到整個列表有序為止。\n氣泡排序法的基本原理：  比較和交換：  從列表的開頭開始，依次比較相鄰的兩個元素。 如果前一個元素大於後一個元素，則交換這兩個元素的位置。 這個過程會將較大的元素「冒泡」到列表的末尾，因此稱為「氣泡排序」。   迭代排序：  重複比較和交換的過程，直到列表完全排序。 每次迭代都會將最大的元素放在列表的末尾，因此每次迭代的範圍逐漸減少。   最佳和最差情況：  在最佳情況下，如果列表已經有序，則氣泡排序會很快結束。 在最差情況下，列表逆序排列，則排序所需的比較和交換次數最多。   時間複雜度：  平均和最壞情況時間複雜度為 O(n^2)，其中 n 是列表的長度。 最佳情況時間複雜度為 O(n)（當列表已經有序時）。   優點：  氣泡排序法簡單易懂，實現容易。 在列表已經接近排序的情況下，氣泡排序可以很快完成排序。   缺點：  氣泡排序法效率較低，時間複雜度高於其他一些排序演算法。 在大部分情況下不建議用於大規模數據排序。    氣泡排序法的程式範例： 下面是一個用 Java 實現的氣泡排序法範例：\npublic class BubbleSort {  public static void bubbleSort(int[] array) {  int n = array.length;  boolean swapped;   // 遍歷列表  for (int i = 0; i \u0026lt; n - 1; i++) {  swapped = false;   // 比較相鄰元素  for (int j = 0; j \u0026lt; n - i - 1; j++) {  if (array[j] \u0026gt; array[j + 1]) {  // 交換元素  int temp = array[j];  array[j] = array[j + 1];  array[j + 1] = temp;   // 設定 swapped 為 true 表示有進行交換  swapped = true;  }  }   // 如果這次迭代沒有進行交換，說明列表已經排序完成，可以提前退出  if (!swapped) {  break;  }  }  }   public static void main(String[] args) {  // 定義一個整數數組  int[] array = {64, 34, 25, 12, 22, 11, 90};   // 輸出排序前的數組  System.out.println(\u0026#34;排序前的數組:\u0026#34;);  for (int num : array) {  System.out.print(num + \u0026#34; \u0026#34;);  }  System.out.println();   // 執行氣泡排序  bubbleSort(array);   // 輸出排序後的數組  System.out.println(\u0026#34;排序後的數組:\u0026#34;);  for (int num : array) {  System.out.print(num + \u0026#34; \u0026#34;);  }  } } 參考文章  ChatGPT 【圖解演算法教學】Bubble Sort 的大隊接力賽 入門|介紹|教學|LeetCode|資料結構 Bubble Sort Algorithm - GreeksForGreeks  ","permalink":"https://roylintw.github.io/blog/algorithms/bubblesort/","tags":["演算法","氣泡排序法"],"title":"氣泡排序法"},{"categories":["心得"],"contents":"我是第三篇文章\n","permalink":"https://roylintw.github.io/blog/third-post/","tags":["程式語言","Java"],"title":"第三篇文章"},{"categories":["健康"],"contents":"對眼睛比較友善的網頁顏色通常是較柔和、低對比度的顏色，避免過於刺眼的亮色和高對比度的搭配。以下是一些常見的推薦顏色搭配和原則：\n背景顏色： 使用柔和的淺色背景（如淺灰色或淺米色）會比純白色更能減少眼睛疲勞。白色背景過於刺眼，尤其在長時間觀看時容易感到不適。\n文字顏色： 選擇深色文字（如深灰或黑色）搭配淺色背景。避免使用過於鮮豔或對比過強的顏色（如紅色或黃色），因為這些顏色會讓眼睛感到刺痛。\n暗模式： 如果是長時間使用設備，暗模式（背景黑色或深灰色，文字白色或淺灰色）也是一個不錯的選擇，可以減少眼睛的疲勞和光線對比。\n避免過多的顏色： 除非有特殊設計需求，否則避免網頁使用過多的顏色。過多鮮豔顏色會讓眼睛難以集中注意力。\n調整亮度： 根據環境光線調整亮度，避免在黑暗環境中使用亮色背景，或是在光線強烈的地方使用過於暗沉的顏色。\n這些基本的設計原則有助於減少視覺疲勞，提升用戶的瀏覽體驗。\n本文由 ChatGPT 生成\n","permalink":"https://roylintw.github.io/blog/%E7%B6%B2%E9%A0%81%E7%94%A8%E4%BB%80%E9%BA%BC%E9%A1%8F%E8%89%B2%E5%B0%8D%E7%9C%BC%E7%9D%9B%E6%AF%94%E8%BC%83%E5%A5%BD/","tags":["網頁","眼睛"],"title":"網頁用什麼顏色對眼睛比較好"},{"categories":["網站"],"contents":"","permalink":"https://roylintw.github.io/blog/dls/dls%E7%94%9F%E6%B4%BB%E5%95%86%E5%9F%8E_day1_%E5%BB%BA%E7%BD%AE%E7%92%B0%E5%A2%83/","tags":["Photos","Game","HTML","Python","New"],"title":"【DLS生活商城】Day1.建置後端環境"},{"categories":["證照"],"contents":"Which two code fragments cause a compilation error? (Choose two.) public class Test { \tpublic static final int MIN = 1; \tpublic static void main(String[] args) { \tint x = args.length; \tif(checkLimit(x)) { \tSystem.out.println(\u0026#34;Java SE\u0026#34;); \t} else { \tSystem.out.println(\u0026#34;Java EE\u0026#34;); \t} \t} \tpublic static boolean checkLimit(int x) { \treturn (x \u0026gt;= MIN) ? true : false; \t} } And given the commands:\njavac Test.java\rjava Test 1 Which two code fragments cause a compilation error? (Choose two.) A. float flt = 100.00F; B. float flt = (float) 1_11.00; C. Float flt = 100.00; D. double y1 = 203.22;float flt = y1; E. int y2 = 100;float flt = (float) y2 ;  題解 字串\u0026quot;1\u0026quot;傳入後，得到長度 1，\n進入 checkLimit( )，x 等於 MIN，得到 true，\n進入第一個 if敘述，答案是 \u0026ldquo;Java SE\u0026rdquo;\n","permalink":"https://roylintw.github.io/blog/oca/oca_36/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第36題 基本型態轉換"},{"categories":["Java"],"contents":"參考連結 基本資料型態\nJava 原始資料型態預設值 primitive data type default value\n","permalink":"https://roylintw.github.io/blog/java/primitive_data_types/","tags":["Java","觀念"],"title":"【Java】基本資料型態 預設值"},{"categories":["證照"],"contents":"題目 Given this code for the classes MyException and Test: public class MyException extends RuntimeException {} public class Test { \tpublic static void main(String[] args) { \ttry { \tmethod1(); \t} catch (MyException ee) { \tSystem.out.println(\u0026#34;A\u0026#34;); \t} \t} \t\tpublic static void method1() { //line n1 \ttry { \tthrow 3 \u0026gt; 10 ? new MyException() : new IOException(); \t} catch (IOException e) { \tSystem.out.println(\u0026#34;I\u0026#34;); \t} catch (Exception e) { \tSystem.out.println(\u0026#34;B\u0026#34;); \t} \t} } What is the result? A. A B. AB C. A compile time error occurs at line n1. D. B E. I  題解 首先呼叫 method1()，\n進入 try區塊，\n因為 3 \u0026lt; 10，拋出 new IOException()，\n接下來，進入到第一個 catch區塊，印出 \u0026ldquo;I\u0026rdquo;，答案是 (E)\n","permalink":"https://roylintw.github.io/blog/oca/oca_196/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第196題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which is the result? A. Compilation fails in the Employee class. B. null : 0 : 0 Jack : 50 : 0 Chloe : 40 : 5000 C. null : 0 : 0 Jack : 50 : 2000 Chloe : 40 : 5000 D. Compilation fails in the Test class. E. Both the Employee class and the Test class fail to compile.  題解 只要有新增一個有參數的建構方法，那空的建構方法也要自己設定。\n","permalink":"https://roylintw.github.io/blog/oca/oca_introduction/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 1Z0-808 介紹"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \ttry { \tint num = 10; \tint div = 0; \tint ans = num/div; \t} catch (ArithmeticException ae) { \tans = 0; \t} catch (Exception e) { \tSystem.out.println(\u0026#34;Invalid calculation\u0026#34;); \t} \tSystem.out.println(\u0026#34;Answer = \u0026#34; + ans); \t} What is the result? A. Answer = 0 B. Invalid calculation C. Compilation fails only at line n1. D. Compilation fails only at line n2. E. Compilation fails at line n1 and line2.  題解 一開始大家可能以為照題目的意思，\n10/0 會報錯 ArithmeticException，\n然後進入第一個 catch區塊， ans = 0，\n可是一開始宣告的區域變數 ans只有在 try區塊看的到，在其他區塊無法看到 ans，\n因此抱錯 ans cannot be resolved to a variable， 答案就是(E)\n","permalink":"https://roylintw.github.io/blog/oca/oca_197/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第197題"},{"categories":["證照"],"contents":"Examine the given definitions: Which statement is true about the implementation of Object-Oriented Programming concepts in the given code ? A. Polymorphism, abstraction, and encapsulation are implemented. B. Only polymorphism and inheritance are implemented. C. Polymorphism, inheritance, and abstraction are implemented. D. Only inheritance and encapsulation are implemented.  題解 Playable p有去操縱 game物件，所以有用到\u0026quot;多型\u0026quot;\n有把屬性變成 private，並只能用 getxx方法取出，所以有用到\u0026quot;封裝\u0026quot;\n","permalink":"https://roylintw.github.io/blog/oca/oca_198/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第198題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tList\u0026lt;String\u0026gt; lst = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;); \tIterator\u0026lt;String\u0026gt; itr = lst.iterator(); \twhile(itr.hasNext()) { \tString e = itr.next(); \tif(e == \u0026#34;C\u0026#34;) { \tbreak; \t} \telse {  continue; \tSystem.out.print(e); \t} \t} \t} Which action enables it to print AB? A. Comment lines 18 to 21. B. Comment line 20. C. Comment line 19. D. Comment line 16.  題解 因為 System.out.print(e)前面有 continue，\n因此無論是字串A、B、D進入 else區塊，\n都不會執行到 System.out.print(e)，\n只要把 20行註解，就可以印出 AB，答案是(C)\n","permalink":"https://roylintw.github.io/blog/oca/oca_199/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第199題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which is the result? A. Compilation fails in the Employee class. B. null : 0 : 0 Jack : 50 : 0 Chloe : 40 : 5000 C. null : 0 : 0 Jack : 50 : 2000 Chloe : 40 : 5000 D. Compilation fails in the Test class. E. Both the Employee class and the Test class fail to compile.  題解 只要有新增一個有參數的建構方法，那空的建構方法也要自己設定。\n","permalink":"https://roylintw.github.io/blog/oca/oca_1/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第1題 建構方法"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which code fragment, when inserted at line 9, enables the code to print true? A. String str2 = str1; B. String str2 = new String(str1); C. String str2 = sb1. toString(); D. String str2 = \u0026ldquo;Duke\u0026rdquo;;  題解 ==比較的是地址值，\n如果第 10行要印出 true的話，\nstr1 跟 str2的地址值要相同，\nstring str2 = str1，就是 str2變數指向 str1的物件，\n兩個變數共用同一個物件，地址值相同，\n答案是(A)\n","permalink":"https://roylintw.github.io/blog/oca/oca_200/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第200題"},{"categories":["證照"],"contents":"Given: public class Test { \tpublic static final int MIN = 1; \tpublic static void main(String[] args) { \tint x = args.length; \tif(checkLimit(x)) { \tSystem.out.println(\u0026#34;Java SE\u0026#34;); \t} else { \tSystem.out.println(\u0026#34;Java EE\u0026#34;); \t} \t} \tpublic static boolean checkLimit(int x) { \treturn (x \u0026gt;= MIN) ? true : false; \t} } And given the commands:\njavac Test.java\rjava Test 1 Which is the result? A. Java SE B. Java EE C. Compilation fails at line n1. D. A NullPointerException is thrown at runtime.  題解 字串\u0026quot;1\u0026quot;傳入後，得到長度 1，\n進入 checkLimit( )，x 等於 MIN，得到 true，\n進入第一個 if敘述，答案是 \u0026ldquo;Java SE\u0026rdquo;\n","permalink":"https://roylintw.github.io/blog/oca/oca_2/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第2題 三元運算式"},{"categories":null,"contents":"一級 system.out.print(\u0026#34;hello\u0026#34;) ","permalink":"https://roylintw.github.io/blog/test2/","tags":null,"title":""}]