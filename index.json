[{"categories":["證照"],"contents":"●場次: 金研院 114 年第 5 次永續發展基礎能力測驗 筆試\n●考試日期: 2025/10/18(六) 14:00\n●考試地點: 育達高中 ●難度: 中等 ●建議準備天數: 14天\n●實際準備天數: 7天\n●分數:\n●金額: 報名費 800元 + 交通 35元\n📌考試介紹： ●辦理機構: 證基會、金融研訓院、保發中心\n●報考資格: 不限\n●測驗題數: 80題(一題1.25分)\n●合格分數: 70分\n●測驗時間: 90分鐘(40分後可交卷)\n●測驗方式: 筆試/電腦(筆試: 一年6場次、電腦: 可到證基會、金研院報名)\n👨‍💻考試心得： 因為平日上班，\n只有晚上所剩無幾的時間可以看書，但回家又很累了，\n所以大概就是每天看1小時左右， 基本就是狂幹考古題。\n這次考試又是在老地方-育達高中，\n每次考金融、銀行相關考試都是在這裡。\n今天是個炎熱的一天，\n下午1點坐公車46號到南京寧安街口，約20分鐘， 走到考場大概是下午1點30分。\n這次永續證照算是人手必備的一張證照，\n所以考試的人算滿多的，\n剩下20分就坐在考場拿手機看阿摩題目。\n原以為這次考試跟前幾次考試一樣，\n考古題都會佔比很多，結果考試一看發現有4成都是沒看到的\u0026hellip;\n只好用觀念去推理，排除不可能的選項，提高答對率。\n這次考試考了綠天鵝事件、溫室氣體盤查、IFRS 17等等，\n綠天鵝事件考前剛好看到，但有點忘記定義，還好有猜到XD\n我覺得難度偏難，\n如果你只有硬背考古題，\n可能會稍微有點危險，\n還是需要理解觀念。\n出考場後，還聽到有人說:「好難哦~」\n@@\n👨‍💻考試技巧： ","permalink":"https://roylintw.github.io/blog/certification/it/%E6%B0%B8%E7%BA%8C%E7%99%BC%E5%B1%95%E5%9F%BA%E7%A4%8E%E8%83%BD%E5%8A%9B%E6%B8%AC%E9%A9%97/","tags":["永續發展基礎能力測驗","介紹","考試心得"],"title":"永續發展基礎能力測驗 介紹、考試心得"},{"categories":["購物"],"contents":"總結 商品資訊: 重量: 320g 尺寸: 19 × 30 × 12 cm\n   費用 金額     商品金額 17,600日元   Buyee手續費 300日元   方案費用 500日元   商品費用折扣金額 -528日元   運送費用(到Buyee日本倉庫) 308台幣   國際運送費用（從Buyee倉庫寄往顧客指定地址） 355日元   店取/宅配手續費 250日元    最近想買一件 Munsingwear 企鵝牌 polo杉給老爸，\n到 momo 查，竟然要價 $6312 台幣!!\nMunsingwear 企鵝牌 男款藏青色舒適透氣吸汗速乾防曬降溫高機能短袖POLO衫 MGVJ2022\n因此想去其他網站看看有沒有比較便宜，\n結果發現\n Yahoo $14,080日幣(當日匯率0.1987) = $2978台幣 樂天 $17,600日幣(當日匯率0.1987) = $3723台幣  Yahoo 樂天 Yahoo 比 樂天 便宜745台幣，\n只可惜 Yahoo 缺貨，沒有適合的尺寸，只能買樂天QQ\n運送\n  Rakuten Global Express 樂天有個 Rakuten Global Express 可以將商品寄送至台灣，\n運費說明\n我的 polo杉大約250~300克，運費約 2140日幣，大概是 425台幣，\n  Buyee\n運送費用\n用 Buyee 的話，大約 295日元，大概是 58台幣，\n哇，這樣用 Buyee 便宜很多耶，\n  Buyee 下單 商品頁面\n選擇顏色、尺寸 \u0026gt; 加入購物車\n購物車頁面 \u0026gt; 訂購 選擇付款方式\n這邊建議使用富邦J卡，日韓一般3% 商品價格計算 一般會以為買日本商品，要看日圓兌台幣哪個划算，\n但其實不是，\n一般流程是 日圓（JPY） ➜ 美元（USD） ➜ 新台幣（TWD）\n 國際發卡組織（Visa / MasterCard）會先用他們自己的日圓兌美元匯率轉換。 然後台灣的發卡銀行會用「美元兌台幣匯率」來轉換。 最後再加上 1.5%～2% 的手續費。 所以其實要看哪個銀行台幣可以換最多美金。 參考比率網  但發卡銀行一般會使用「帳單結帳日」的 發卡銀行內部結匯匯率（非即期匯率），所以只能做個參考 VISA 匯率 1 JPY = 0.006948 USD\n匯率比較 這邊匯率目前最好是第一銀行 29.57， 再來是要刷的富邦銀行 29.5995\n信用卡回饋比較 第一銀行-iLEO卡: 2% 富邦銀行-富邦J卡: 3%\n整理    欄位1 匯率 消費回饋 結果     第一銀行 29.57 2% 176000.00694829.57*0.02=72.33   富邦銀行 29.5995 3% 176000.00694829.5995*0.03=108.62    比較結果富邦比第一的回饋多36元!\n登錄信用卡資訊 選擇方案 運輸保障: 因運輸途中事故造成的破損、遺失\n檢品: 顏色・尺寸錯誤、與商品頁面不符 因為第一次買海外東西，所以我選基本方案(運輸保障+檢品)\n選擇優惠券 這邊只能選\u0026quot;首次購物限定 商品金額 3%OFF 優惠券\u0026quot;\n商品金額 目前折下來的金額是17872日圓 = 3781 台幣。    費用 金額     商品金額 17,600日元   Buyee手續費 300日元   方案費用 500日元   商品費用折扣金額 -528日元   確認後，點擊確定購買         訂購成功 查看訂單 我的主頁 \u0026gt; 代購 \u0026gt; 訂單\n時間 下單: 2025/7/28 20:33 完成購買: 2025/7/28 20:39 出貨: 2025/7/29 20:24 抵達倉庫: 2025/7/31 11:58 抵達台灣: 取貨:\n支付國際運費 商品顯示\u0026quot;抵達倉庫\u0026quot;後，就可以支付運費囉~\n點擊「此頁面」\n勾選包裹 \u0026gt; 點擊「便利商店取貨」\n選擇取貨門市 \u0026gt; 選擇寄送方式\n填寫收件人資料 \u0026gt; 填寫完成 \u0026gt; 點擊「確定」\n點擊「確定」\n勾選「付款方式」 \u0026gt; 勾選「已完成實名認證，並理解預先委任制度」 \u0026gt; 點擊「付款確定」\n點擊「確定」 可以下載 PDF 查看明細\n國際運費明細\n發送情報\n📌定義： 前往 Download\n🧠原理： ⏱️ 時間複雜度： ✅ 優點：    ❌ 缺點：    💡 適合用在哪？ 👨‍💻程式： 🧾執行結果： 📚參考文章  ChatGPT     欄位1 欄位2 欄位3     資料1 資料2 資料3   資料4 資料5 資料6    ","permalink":"https://roylintw.github.io/blog/%E6%97%A5%E6%9C%AC%E7%B6%B2%E7%AB%99%E8%B3%BC%E7%89%A9%E7%9B%B4%E9%80%81%E5%8F%B0%E7%81%A3todo/","tags":["日本網站","台灣"],"title":"日本網站購物直送台灣"},{"categories":["資料結構"],"contents":"何謂「資料清洗」? 資料清洗是指在資料分析或建模之前，對原始資料進行檢查、修正或刪除不正確、不完整、重複或不一致的數據，以提升資料的品質與可靠性。\n我有一份目標信用卡網頁的 html 元素，\n可以參考此文件台企銀-銀色之愛信用卡網頁html元素.txt\n可以看到有很多可以看到有很多不需要的元素， 例如: 標題列、頁尾 \u0026hellip;\n然而我需要的只有下面紅框處的必要資訊，\n有幾種做法\n 去除不需要區塊 只篩需要的區塊  作法1 去除不需要區塊  好處:\n1.如果知道有哪些區塊是一定不需要的， 因為某個銀行的信用卡頁面一定是相似的，\n可以很容易篩掉不需要的元素，即使有新增的元素，也不會刪除， 避免新的優惠資訊被遺漏。\n2.減少 tasklet 之間傳輸的資料量 壞處: 如果有新的不需要元素，需要手動增加條件篩選。  作法2 只篩需要的區塊  好處: 簡單暴力，只要找到固定放置優惠訊息的區塊，就可以固定抓優惠。 壞處: 若有新的優惠元素，可能就因此錯過。  移除 HTML 噪音 統一日期格式 清洗金額格式 分類活動內容 適用卡別統一格式 去除重複或過期資料 🔧 設計模式說明與對應\n BankPageFilterStrategy（介面 / 抽象類別） 📌 用途：定義不同銀行網頁過濾與清洗邏輯的策略接口。 📌 設計模式：策略模式（Strategy Pattern）中的 策略介面 📌 方法範例：  java 複製 編輯 public interface BankPageFilterStrategy { Document cleanRawHtml(Document rawHtml); boolean isValidCardElement(Element cardElement); } 2. CathayFilterStrategy（具體策略類別） 📌 用途：國泰銀行頁面專屬的過濾邏輯，例如處理它獨有的 HTML 結構、無用區塊、折扣字樣等。 📌 設計模式：策略模式中的 具體策略 📌 範例說明：\njava 複製 編輯 public class CathayFilterStrategy implements BankPageFilterStrategy { @Override public Document cleanRawHtml(Document rawHtml) { // 去除廣告區塊、格式調整等 }\n@Override public boolean isValidCardElement(Element cardElement) { // 根據 class 或其他判斷此是否為有效卡片區塊 }  } 3. DefaultFilterStrategy（預設策略） 📌 用途：當某個銀行沒有特別處理時，採用的通用過濾策略。 📌 設計模式：策略模式中的 備用具體策略 📌 好處：提高擴展性，不需每家銀行都實作。\nBankCrawlerFactory（工廠類別） 📌 用途：根據銀行名稱產出對應的處理物件（如 FilterStrategy 或 Extractor） 📌 設計模式：工廠模式（Factory Pattern） 📌 範例說明：  java 複製 編輯 public class BankCrawlerFactory { public static BankPageFilterStrategy getFilterStrategy(String bankName) { switch(bankName) { case \u0026ldquo;Cathay\u0026rdquo;: return new CathayFilterStrategy(); case \u0026ldquo;Taishin\u0026rdquo;: return new TaishinFilterStrategy(); default: return new DefaultFilterStrategy(); } }\npublic static CardExtractor getCardExtractor(String bankName) { switch(bankName) { case \u0026quot;Cathay\u0026quot;: return new CathayCardExtractor(); default: return new GenericCardExtractor(); } }  } 5. CathayCardExtractor（特定資料提取器） 📌 用途：負責從國泰的網頁中提取卡片名稱、優惠文字、年費資訊等。 📌 設計模式：策略模式中的具體實作或與工廠模式配合使用的「產品」 📌 方法可能包含：\njava 複製 編輯 public class CathayCardExtractor implements CardExtractor { public ListextractCards(Document cleanedHtml) { // 提取卡名、優惠、條件等 } } 6. GenericCardExtractor（通用提取器） 📌 用途：對結構規則較一致或資料乾淨的銀行頁面使用的通用擷取器。 📌 設計模式：策略或抽象工廠中的通用實作 📌 用途：快速支援新銀行，等未來有需求再客製化。\n🧠 總結：整體架構概念 [ 爬蟲結果 Document ] ↓ [ BankCrawlerFactory ] \u0026ndash;\u0026gt; 給你一個 BankPageFilterStrategy + CardExtractor ↓ [ BankPageFilterStrategy.cleanRawHtml ] ↓ [ CardExtractor.extractCards ] ↓ [ 清洗好的卡片資訊 CardInfo List ] ✅ 優點 優點\t說明 可擴展性高\t新增一家銀行只要增加新的 FilterStrategy 或 Extractor。 維護性強\t每家銀行邏輯分開，不會影響其他銀行。 符合 SOLID 原則\t特別是 OCP（開放封閉原則）、SRP（單一職責原則）。\n🎯 總覽：使用到的設計模式 類別\t設計模式\t解釋 BankPageFilterStrategy（介面）\t策略模式（Strategy Pattern）\t定義不同銀行頁面清洗邏輯的策略介面。 CathayFilterStrategy, DefaultFilterStrategy\t策略模式 – 具體策略\t為特定銀行提供專屬過濾邏輯。 BankCrawlerFactory\t工廠模式（Factory Pattern）\t根據銀行名稱產出對應策略或擷取器物件。 CathayCardExtractor, GenericCardExtractor\t策略模式或抽象工廠的產品\t擴展特定銀行資料的擷取邏輯。 整體流程\t依賴反轉原則（DIP）+ 開放封閉原則（OCP）\t新增銀行時不改動核心邏輯，只新增類別。\n✅ 對應說明（圖解式） text 複製 編輯\n使用策略模式 CardProcessingSystem │ ├── uses → BankPageFilterStrategy (interface) │ ├── CathayFilterStrategy (實作) │ └── DefaultFilterStrategy (實作) │ ├── uses → CardExtractor (interface) │ ├── CathayCardExtractor │ └── GenericCardExtractor\n使用工廠模式 BankCrawlerFactory ├── getFilterStrategy(\u0026ldquo;Cathay\u0026rdquo;) → CathayFilterStrategy ├── getCardExtractor(\u0026ldquo;Cathay\u0026rdquo;) → CathayCardExtractor 🔍 設計模式關鍵定義對照\n 策略模式 (Strategy Pattern) 定義一系列演算法，把它們封裝起來，並且可以互相替換，使得演算法可以獨立於使用它的客戶變化。  在你的系統中，BankPageFilterStrategy 定義了如何清洗 HTML，CardExtractor 定義了如何擷取優惠資料。\n不同銀行實作自己的版本。\n工廠模式 (Factory Pattern) 提供一個建立物件的介面，讓子類決定實例化哪一個類別。  BankCrawlerFactory 根據銀行名稱，建立對應的 FilterStrategy 或 CardExtractor。\n這樣主程式就不用 new CathayFilterStrategy()，可避免耦合。\n✔ 補充：為什麼不是「裝飾者模式」或「觀察者模式」？ 不是裝飾者模式：因為你沒有層層包裝物件增加行為，而是選擇不同策略執行邏輯。\n不是觀察者模式：沒有事件通知機制。\n也不是模板方法：因為沒有定義抽象流程只讓子類覆寫某部分。\n🧠 總結 這套架構是典型的：\n策略模式：讓不同銀行可定義自己的過濾與擷取行為。\n工廠模式：集中建立物件邏輯，符合開放封閉原則。\n依賴反轉 + 介面導向設計：讓主流程不依賴具體實作。\n📌定義： 前往 Download\n🧠原理： ⏱️ 時間複雜度： ✅ 優點：    ❌ 缺點：    💡 適合用在哪？ 👨‍💻程式： 🧾執行結果： 📚參考文章  ChatGPT     欄位1 欄位2 欄位3     資料1 資料2 資料3   資料4 資料5 資料6    ","permalink":"https://roylintw.github.io/project/credit-card-recommendation-system/%E4%BF%A1%E7%94%A8%E5%8D%A1%E6%8E%A8%E8%96%A6%E7%B3%BB%E7%B5%B1day5-%E4%BF%A1%E7%94%A8%E5%8D%A1%E7%B6%B2%E9%A0%81%E8%B3%87%E6%96%99%E6%B8%85%E6%B4%97/","tags":["資料結構","Stack"],"title":"資料結構 Stack"},{"categories":["VS Code"],"contents":"   快捷鍵名稱 快捷鍵 功能     Delete Line Ctrl + D 刪除整行   Copy Line Up / Down Shift + Alt + ↑ / Shift + Alt + ↓ 向上/下複製當前行   View: Zoom in Ctrl + + 放大   View: Zoom out Ctrl + - 縮小   Go Back Alt + ← 回到上一個游標位置    ","permalink":"https://roylintw.github.io/blog/vscode/vscode%E5%BF%AB%E6%8D%B7%E9%8D%B5%E6%95%B4%E7%90%86/","tags":["VS Code","快捷鍵"],"title":"[VS Code]實用的快捷鍵整理"},{"categories":["證照"],"contents":"前往官網 前往 ITE資訊專業人員鑑定\n報名流程 考生服務 \u0026gt; 線上報名\n點選 ITE / EEC 大會考\n選擇想要報名的考區\n因為住台北，所以就選擇報考\u0026quot;北區\u0026quot;\n勾選「個人資料同意提供」\u0026gt; 我同意\n點擊「登記報名」\n點擊「開始報名」\n因為我是第一次報名，所以點擊「初次報名」\n填寫基本資料 \u0026gt; 下一步\n選擇測驗科目 \u0026gt; 下一步\n一次最多可報名3科，建議一次報滿，因為一季都要等很久，\nOS: 報名費也太貴了吧\u0026hellip;\n核對報名資料 \u0026gt; 下一步 \u0026gt; 確定\n列印繳費單/繳交費用 \u0026gt; 下一步 \u0026gt; 確定\n建議選 ATM 繳費，免繳手續費~\n線上報名完成!\n繳費流程 ATM 繳費流程說明\n點擊「列印繳費單」 \u0026gt; 儲存\n繳費 可以使用網路銀行或行動銀行繳費，\n建議使用第一銀行繳費，免手續費哦~\n繳費完成後， 到 報名紀錄/補印繳費單 \u0026gt; 查詢 確認繳費狀態\n需要等一段時間後，系統才會更新\n接著就要準備考試囉QQ\n","permalink":"https://roylintw.github.io/blog/certification/it/%E5%A0%B1%E5%90%8Dite%E8%B3%87%E8%A8%8A%E5%B0%88%E6%A5%AD%E4%BA%BA%E5%93%A1%E8%80%83%E8%A9%A6/","tags":["ITE","報名"],"title":"報名ITE資訊專業人員考試"},{"categories":["信用卡推薦系統"],"contents":"進入官網 OpenAI 官網 註冊帳號 新增金鑰 登入後，看到左側選單\nAPI keys \u0026gt; Create new secret key\n輸入資訊:\n Name: 隨意 Project: 選擇 Default project Permissions: All 輸入完成後，點擊「Create secret key」\n金鑰就產生囉! 這組金鑰未來用在程式呼叫 API 使用~\n這時，我習慣會在專案底下新增一個 txt 儲存金鑰，避免之後忘記，\n就把剛剛的金鑰 copy \u0026amp; paste\n  首次測試 API 打 API 後的回應訊息，429 TOO_MANY_REQUESTS\n帳戶顯示預算有5美金，為什麼打 API 回覆 429 TOO_MANY_REQUESTS? 到帳單查看\nBilling \u0026gt; Overview Credit remaining 為 0\n應該就是這個才導致無法成功打 API，\n後來我參考了這篇文章別再花冤枉錢！OpenAI 免費 API 教學，額度申請全攻略（新手必看）\n需要5美金才能激活帳戶，\n所以我就先儲值拉~\n新增付款方式 Billing \u0026gt; Add Payment details \u0026gt; Continue\nAdd Payment details 郵務業務- 中文地址英譯\nConfigure payment  Initial credit purchase: 5 取消勾選 Yes, automatically recharge my card when my credit balance falls below a threshold 點擊「Continue」  Payment summary 會有額外的 5% 稅金，0.25美金，\n確認正確後，點擊「Confirm payment」， 開始噴錢囉~ 付款完成後，帳戶就有5美金囉!\n再次確認 Usage，就變成 $120 了\n總共花了 154台幣，換 5.25美金，匯率約 29.33\n啟用「資料共享（Data controls）」，領取每日免費額度 因為一開始測試，總是花費最多的時候，\n只要開始「資料共享（Data Controls）」，與 OpenAI 分享你的輸入和輸出，\n就可以獲得許多免費的額度!\nData controls \u0026gt; Sharing \u0026gt; Enabled for all projects \u0026gt; Save\n勾選「By checking this box, I understand and agree to the Content Sharing Agreement above.」 \u0026gt; Submit\n測試 我又打了一次 API，這次就有成功取得 OpenAI 解析的內容了\n解析的網頁: 銀色之愛信用卡 - 台灣企銀 接著到 Usage 查看這次的使用量，\n發現這次共花了 8493 個 tokens!\n","permalink":"https://roylintw.github.io/project/credit-card-recommendation-system/%E4%BF%A1%E7%94%A8%E5%8D%A1%E6%8E%A8%E8%96%A6%E7%B3%BB%E7%B5%B1%E4%BD%BF%E7%94%A8openai%E7%9A%84api/","tags":["OpenAI","API"],"title":"[信用卡推薦系統]使用 OpenAI 的 API"},{"categories":["信用卡推薦系統"],"contents":"使用 Spring Initializr 快速建立 Spring Boot 專案 🔗 網址： https://start.spring.io 步驟：\n 開啟 start.spring.io 填寫專案基本資訊：   Project: Maven（或 Gradle） Language: Java Spring Boot: 建議選最新穩定版（如 3.５.x）  輸入 Metadata：   Group（組織、公司、網站名稱）: com.smallbookboy Artifact（專案的名稱或模組名稱、JAR/war 檔名）: credit-card-recommendation-system-batch Name（專案的可讀名稱）: Small Book Boy Credit Card Recommendation System Batch Description（專案的描述）: 信用卡推薦系統批次 Package name: com.smallbookboy.credit-card-recommendation-system-batch  點擊「GENERATE」，下載 zip zip 解壓縮至專案資料夾下\n IDE 開啟專案\n目前建立專案算告一段落，接下來就是 import 需要的 Libraries pom 加入 Dependencies   ✅ Spring Batch ✅ MySQL Driver ✅ Lombok  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-batch\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.38\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 完成以上步驟後，就建立好一個 Spring Batch 專案囉!\n","permalink":"https://roylintw.github.io/project/credit-card-recommendation-system/%E4%BF%A1%E7%94%A8%E5%8D%A1%E6%8E%A8%E8%96%A6%E7%B3%BB%E7%B5%B1%E5%BB%BA%E7%AB%8Bspringbatch%E5%B0%88%E6%A1%88/","tags":["Spring Batch"],"title":"[信用卡推薦系統]建立 Spring Batch 專案"},{"categories":["Linux"],"contents":"   指令 功能 說明     df -h 查看磁碟空間的使用情況 df: disk free，用來顯示磁碟空間資訊 -h: human-readable，顯示單位為 KB/MB/GB    ","permalink":"https://roylintw.github.io/blog/linux/linux%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/","tags":["Linux","指令"],"title":"Linux指令整理"},{"categories":["docker"],"contents":"   指令 功能 說明     docker ps 查看目前正在執行中的容器（containers） ps: Process Status，容器的執行狀態   docker ps -a 查看目前正在執行中的容器（containers）（包括已停止） -a: all   docker images 查看 image    docker rmi \u0026lt;image_id\u0026gt; 刪除 image rmi: remove image   docker stop \u0026lt;container_id\u0026gt; 暫停 container    docker rm \u0026lt;container_id\u0026gt; 刪除 container    docker rm -f \u0026lt;container_id\u0026gt; 刪除 container -f: force（強制），即使容器正在執行中也會先停止再刪除    ","permalink":"https://roylintw.github.io/blog/docker/docker%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/","tags":["docker","指令"],"title":"docker指令整理"},{"categories":["信用卡推薦系統"],"contents":"連線資料庫 點擊插頭 icon \u0026gt; 選擇 MySQL \u0026gt; Next\n輸入 Password \u0026gt; 測試連線 \u0026gt; Download(如果有缺少元件才需要) 連線錯誤 Public Key Retrieval is not allowed\n回到連線設定 \u0026gt; Driver properties \u0026gt; allowPublicKeyRetrieval 改為 TRUE\n再次測試連線，連線成功 \u0026gt; OK \u0026gt; Finish\n新增資料庫 右鍵資料庫 \u0026gt; Create New 資料庫\n輸入 Database name \u0026gt; OK\n新資料庫就出現囉!\n新增資料表 資料庫 \u0026gt; SQL編輯器 \u0026gt; 開啟SQL腳本 新增 users(使用者) 資料表\nCREATE TABLE users ( user_id BIGINT PRIMARY KEY COMMENT \u0026#39;使用者 ID\u0026#39;, name VARCHAR(100) COMMENT \u0026#39;姓名\u0026#39;, age INT COMMENT \u0026#39;年齡\u0026#39;, gender CHAR(1) COMMENT \u0026#39;性別（M/F）\u0026#39;, income DECIMAL(15, 2) COMMENT \u0026#39;年收入\u0026#39;, job VARCHAR(100) COMMENT \u0026#39;職業\u0026#39;, marital_status VARCHAR(50) COMMENT \u0026#39;婚姻狀態\u0026#39;, education VARCHAR(100) COMMENT \u0026#39;教育程度\u0026#39;, location VARCHAR(100) COMMENT \u0026#39;居住地區\u0026#39;, created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;註冊時間\u0026#39; ); 重新 refresh，就可以看到剛剛新增的資料表\n","permalink":"https://roylintw.github.io/project/credit-card-recommendation-system/%E4%BF%A1%E7%94%A8%E5%8D%A1%E6%8E%A8%E8%96%A6%E7%B3%BB%E7%B5%B1%E5%BB%BA%E7%AB%8B%E8%B3%87%E6%96%99%E5%BA%AB%E5%92%8C%E8%B3%87%E6%96%99%E8%A1%A8/","tags":["資料庫","資料表"],"title":"[信用卡推薦系統]建立資料庫和資料表"},{"categories":["sql","DBeaver"],"contents":"下載 前往下載網址 前往 Download\n開始下載 DBeaver Community \u0026gt; 點選 Windows(installer) \u0026gt; 雙擊下載\n安裝 執行安裝檔 雙擊 dbeaver-ce-25.1.1-x86_64-setup.exe \u0026gt; OK \u0026gt; 下一步 \u0026gt; 我同意 \u0026gt; 下一步 \u0026gt; 下一步 \u0026gt; 下一步 \u0026gt; 安裝 \u0026gt; 完成 確認是否安裝成功 開啟 DBeaver Do not share data \u0026gt; Confirm\nYes\n","permalink":"https://roylintw.github.io/blog/sql/%E5%AE%89%E8%A3%9Ddbeaver%E6%95%99%E5%AD%B8/","tags":["sql","DBeaver","安裝"],"title":"安裝  DBeaver 教學"},{"categories":["SourceTree"],"contents":"問題描述 最近需要 Clone GitLab 上的專案，\n但 Clone 時一直顯示錯誤，\n使用 source clone https://gitlab.xxx.com.tw/xxx.git 顯示 Command: git -c diff.mnemonicprefix=false -c core.quotepath=false --no-optional-locks ls-remote https://gitlab.xxx.com.tw/xxx.git Output: Error: fatal: unable to access \u0026#39;https://gitlab.xxx.com.tw/xxx.git/\u0026#39;: SSL certificate problem: self signed certificate in certificate chain GitLab 伺服器需要憑證機構（CA）簽發的 SSL 憑證，而你是用自簽（self signed）的 SSL 憑證。\n解決方法 本機新增 GitLab 伺服器的 SSL 憑證\n1.匯出 GitLab 伺服器的 SSL 憑證\n以 google 為例 點擊已建立安全連線 \u0026gt; 憑證有效 \u0026gt; 詳細資料 \u0026gt; 匯出\n2.新增本機憑證\n確認語法\nbash git config --global --get http.sslCAInfo\n※http.sslCAInfo是什麼?\nhttp.sslCAInfo 是 Git 的一個設定項目，用來指定 SSL 憑證授權中心（CA, Certificate Authority）憑證檔案的位置，以便 Git 在透過 HTTPS 連線時驗證伺服器端的憑證是否可信。\n確認後新增憑證，\n新增語法\nbash git config --global http.sslCAInfo /path/to/your/custom-certificate.crt\n新增完成後，再次到 clone 分頁抓取遠端分支時，就會跳出輸入帳密的畫面代表 SSL 通過。\n","permalink":"https://roylintw.github.io/blog/sourcetree/sourcetree%E4%BD%BF%E7%94%A8ssl%E9%80%A3%E7%B7%9Agitlab/","tags":["SourceTree","SSL","GitLab"],"title":"[SourceTree]使用SSL連線GitLab(已解決)"},{"categories":["sql","mysql"],"contents":"下載 前往下載網址 前往 MySQL Community Downloads\n選擇版本和下載點 選擇最新版本，選擇第二個下載點 直接下載 這時畫面上會出現 Login 和 Sign Up 按鈕，\n直接無視，\n點擊下面的 No thanks, just start my download. ，直接下載即可~ 安裝 執行安裝檔 雙擊 mysql-installer-community-xxx.msi 檔案，\n按 Execute，接下來一直按 Next，\n預設 port 3306，按 Next，\n設定一組密碼，記得要記住哦，重要!\n接下來一直按 Next，最後按 Execute 就完成囉 確認是否安裝成功 控制集 \u0026gt; 程式集 \u0026gt; 程式和功能 加入環境變數 步驟：\n 右鍵點選「本機」 →「內容」 點選左側「進階系統設定」 在「系統內容」中，點選「環境變數」 在「系統變數」中，找到並點選「Path」→ 點選「編輯」 點選「新增」，貼上：  YourPath\\MySQL\\MySQL Server 8.0\\bin 按「確定」儲存並關閉所有視窗\n關閉並重新開啟 CMD 或 PowerShell，輸入：  mysql -u 你的帳號 -p 再輸入密碼，\n如果成功，會顯示 MySQL 版本號。 下載 DBeaver 因為 MySQL 本身無提供清晰明確的介面去操作，所以需要下載 DBeaver 來方便我們使用，\n可參考文章: 安裝 DBeaver 教學\n","permalink":"https://roylintw.github.io/blog/sql/%E5%AE%89%E8%A3%9Dmysql%E6%95%99%E5%AD%B8/","tags":["sql","mysql","安裝"],"title":"安裝mysql教學"},{"categories":["STS"],"contents":"問題描述 最近在看專案結構時，\n想透過 log 觀看跑到哪個 method，\n但一直沒有印在 Console 視窗裡面，\n調了 log.level 也是一樣， 真奇怪\u0026hellip;\n解決方法 後來發現印很多 log 後，前面的 log 就會消失，\n因此去看一下設定，\n發現原來問題就在這裡!!!\n如果要停止太多行時自動清除 log，\n以下路徑設定 Windows \u0026gt; Preferences \u0026gt; Run/Debug \u0026gt; Console \u0026gt; 取消勾選 Limit console output ![image](../../images/[STS] Console Logs 太多被洗掉的原因1.jpeg) ![image](../../images/[STS] Console Logs 太多被洗掉的原因2.jpeg)\n","permalink":"https://roylintw.github.io/blog/sts/console%E7%9A%84log%E8%A8%8A%E6%81%AF%E8%A2%AB%E6%B4%97%E6%8E%89%E5%8E%9F%E5%9B%A0/","tags":["STS","Console"],"title":"[STS] Console Logs 太多被洗掉的原因(已解決)"},{"categories":["日記"],"contents":"今日目標： 英文\n 單字: 7000單字 Unit 文法 哥倫布 文法庫 Unit  研究所 英文(B) 資訊科技概論\n 114-13~16  資訊管理導論 演算法 心得： 今天提早出門，\n去公司附近的路易莎吃早餐，\n點了老套餐，麥香蔬菜跟一杯英式奶茶，\n一整天都在幫同事做行動銀行Bug測試報告，\n由於測試手機太慢，導致測試速度也很慢，\n有時候在想，與其做這些測試報告，還不如去多看專案結構對我的職涯還比較有幫助。\n在快 4點的時候，我有改去看專案架構，\n然後剛好發現以前 Console log 被洗掉的原因，\n原來是 STS 有設定超過幾行就清掉的設定XD\n晚上跟沛彤吃麻子辣，度過了忙碌的一天。\n明天目標： 英文\n 單字: 7000單字 Unit 文法 哥倫布 文法庫 Unit  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250513/","tags":["日記","2025"],"title":"20250513(二) 製作行動銀行測試報告"},{"categories":["log"],"contents":"   標籤名稱 說明 常用屬性     \u0026lt;Configuration\u0026gt; Log4j2 的根標籤，用來包住整個設定 status（設定 log4j2 自己的 log level）monitorInterval（熱重載）   \u0026lt;Properties\u0026gt; 定義變數，用來重複使用或抽出路徑等 無（內含 \u0026lt;Property name=\u0026quot;\u0026quot;\u0026gt;）   \u0026lt;Property\u0026gt; 宣告單一變數 name（變數名稱）   \u0026lt;Appenders\u0026gt; 定義所有輸出管道（log 要輸出去哪） 無   \u0026lt;Console\u0026gt; 將 log 輸出到主控台（stdout） name、target（SYSTEM_OUT 或 SYSTEM_ERR）   \u0026lt;File\u0026gt; 輸出 log 到一個固定檔案 name、fileName   \u0026lt;RollingFile\u0026gt; 輸出 log 到可輪替檔案（可設最大大小與備份） fileName、filePattern   \u0026lt;RollingRandomAccessFile\u0026gt; 高效能版本的 RollingFile，支援隨機存取 name、fileName、filePattern   \u0026lt;Policies\u0026gt; 定義輪替規則 無（需內含 \u0026lt;TimeBasedTriggeringPolicy\u0026gt; 等）   \u0026lt;TimeBasedTriggeringPolicy\u0026gt; 按時間進行 log 輪替 interval（間隔秒、分鐘、天等）modulate（對齊時間）   \u0026lt;SizeBasedTriggeringPolicy\u0026gt; 按大小進行 log 輪替 size（如 \u0026quot;10MB\u0026quot;）   \u0026lt;DefaultRolloverStrategy\u0026gt; 設定備份檔案保留數量等 max（最多保留幾份備份）   \u0026lt;PatternLayout\u0026gt; 控制 log 的輸出格式 pattern（格式範本）   \u0026lt;Loggers\u0026gt; 包含所有 logger 的定義 無   \u0026lt;Logger\u0026gt; 定義特定 package/class 的 logger name、level、additivity   \u0026lt;AsyncLogger\u0026gt; 非同步 logger，效能更好 同 \u0026lt;Logger\u0026gt;   \u0026lt;Root\u0026gt; 預設（最上層）logger level   \u0026lt;AsyncRoot\u0026gt; 非同步 root logger 同 \u0026lt;Root\u0026gt;   \u0026lt;AppenderRef\u0026gt; 指定 logger 要用哪些 appender ref（對應 appender 的 name）   \u0026lt;Filters\u0026gt; 為 logger 或 appender 設定過濾條件 無（內含 \u0026lt;ThresholdFilter\u0026gt; 等）   \u0026lt;ThresholdFilter\u0026gt; 過濾某個等級以下的 log，不處理 level（如 info）onMatch / onMismatch    📚參考文章  ChatGPT  ","permalink":"https://roylintw.github.io/blog/logging/log4j2/","tags":["log","log4j2","標籤","tag"],"title":"log4j2 標籤 介紹"},{"categories":["日記"],"contents":"今日目標： 英文\n 單字: 7000單字 Unit 文法 哥倫布 文法庫 Unit  研究所 英文(B) 資訊科技概論\n 114-8(已完成)、9  資訊管理導論 演算法 心得： 今天早上再申請共用資料夾、OCP 權限，\n然後前幾天完成的調整文字需求需要產生差異檔跟測試，\n結果發現有一個地方沒改到，慘\u0026hellip;\n下午改完後，前輩請我幫她測試行銀的需求，\n可是主管突然發了兩個需求給我，雖然不難，但需要跟其他同事討論一下，\n明天跟後天要教育訓練，希望可以順利~\n明天目標： 英文\n 單字: 7000單字 Unit 文法 哥倫布 文法庫 Unit  研究所 英文(B) 資訊科技概論\n 114-9  資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250505/","tags":["日記","2025"],"title":"20250505(一)開始接需求的第一天"},{"categories":["演算法"],"contents":"📌定義： 為什麼要叫銀行家演算法? 「銀行家演算法（Banker\u0026rsquo;s Algorithm）」之所以叫這個名字，是因為它的資源分配邏輯像極了銀行放貸的風險控制機制。這個名稱是由電腦科學家 Edsger Dijkstra 所命名的。\n✅ 為什麼叫「銀行家」？ 想像一個銀行（banker）在考慮是否借錢給多個客戶（processes）時，會這樣想：\n❝ 如果我把這筆錢借出去，會不會導致整個銀行無法滿足其他客戶最低需求，造成資金鏈斷裂？ ❞\n所以銀行家會在每次放貸（資源分配）前：\n評估客戶最多還會需要多少資金（Maximum claim）；\n檢查目前是否還有足夠資金可以應付所有客戶的最壞情況；\n只有在系統整體安全的情況下才會批准借出。\n這跟作業系統中：\n程序（Processes）向系統請求資源（如記憶體、I/O）；\n系統只在能保證安全（無死結）時才會分配資源； 非常相似。\n✅ 簡單對照表： 銀行場景\t作業系統對應 銀行貸款給客戶\t系統分配資源給程序 客戶聲明最大貸款額\t程序聲明最大資源需求 銀行檢查是否安全\t系統檢查是否會進入不安全狀態（可能死結）\n✅ 總結： 這個演算法被稱為「銀行家演算法」，是因為它模擬銀行在謹慎放貸時的風險控制邏輯，確保即使每個客戶都在最壞情況下提出最大需求，也不會讓銀行破產（對應於系統進入死結狀態）。 🧠原理： ⏱️ 時間複雜度： ✅ 優點：    ❌ 缺點：    💡 適合用在哪？ 👨‍💻程式： 🧾執行結果： 📚參考文章  ChatGPT  ","permalink":"https://roylintw.github.io/blog/algorithms/todo_bankers_algorithms/","tags":["演算法","銀行家演算法"],"title":"銀行家演算法"},{"categories":["日記"],"contents":"今日目標： 英文\n 單字: 7000單字 Unit 文法 哥倫布 文法庫 Unit  研究所 英文(B) 資訊科技概論\n 114-7(已完成)  資訊管理導論 演算法 心得： 今天半夜行動銀行好像出了問題，\n同事都在極力搶救，\n問題好像是取亂數值的問題。\n英文口說  glasses/eye glasses (n.) 眼鏡 e.g. update my eye glasses、get new glasses ※glass (n.) 玻璃 generous (n.) 大方 wrinkle (n.) 皺紋 heart palpitations (n.) 心悸 e.g. Coffee causes heart palpitations. = Coffee makes my heart race. I\u0026rsquo;m going to have grey hair when I get older. (n.) 我將會有白頭髮／灰白頭髮  明天目標： 英文\n 7000單字 Unit06  研究所 英文(B) 資訊科技概論\n 114-8  資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250501/","tags":["日記","2025"],"title":"20250501(四)五一勞動節放假"},{"categories":["日記"],"contents":"今日目標： 英文\n 文法 哥倫布 文法庫 Unit1  研究所 英文(B) 資訊科技概論\n 114-4  資訊管理導論 演算法 心得： 英文口說 今天早上在測試昨天包版失敗的問題， 發現原來是 setting.xml 設定到 uat 的 cicd 環境， 由於測試機沒有開通防火牆，因此產生 PKIK 憑證問題， 後來更改檔案名稱，讓 project 自動吃原本的 settings.xml。\n下午前輩請我協助測試網路銀行的 email變更設定， 於是借了我的網銀帳號測試， 第一次測試時發現驗證日期顯示異常，但可以變更email， 第二次測試時驗證日期正常，但無法變更email， 後來前輩找到驗證日期的問題並調整好當天上版， email的問題則發信詢問中心帳務主機副科， 由於明天5/1(四)勞動節放假， 只能等到禮拜五再處理了~\n另外，今天還遇到以前彰銀的同事，真巧XD\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250430/","tags":["日記","2025"],"title":"20250430(三)日記-專案包版、網銀email更改及日期顯示失敗"},{"categories":["金融"],"contents":"💼 OBU = Offshore Banking Unit（國際金融業務分行） ✅ 中文解釋： 國際金融業務分行，簡稱「國際金融中心」、「OBU」，是一種專門提供離岸金融服務的銀行業務單位，通常設立於一個國家的金融機構內，但其服務對象僅限於非本國居民或非本地貨幣。\n📌 主要特點：\n項目\t說明 📍 設立地點\t設於銀行內部（例如台灣的商業銀行） 💼 服務對象\t海外公司、外國人、本地居民的外幣帳戶 💰 幣別\t只使用外幣（如美元）進行交易 🚫 限制\t不可對本地居民提供新台幣業務 🧾 稅務優惠\t通常享有低稅甚至免稅待遇 🔒 管制鬆綁\t有較自由的金融管制（如資本進出） 🏦 在台灣的情境（具體範例）： 台灣自 1983 年開放設立 OBU，讓銀行能對外國公司或個人辦理外幣存放款、國際貿易融資、外幣匯兌等業務。\n例如：一家設在台灣的外銀可以透過 OBU，為香港公司辦理美元融資。\n台灣居民也可以開 OBU 帳戶進行合法的境外資金操作（需符合規定）。\n📚參考文章  ChatGPT  ","permalink":"https://roylintw.github.io/blog/finance/obu/","tags":["金融","obu"],"title":"什麼是 OBU?"},{"categories":["日記"],"contents":"今日目標： 英文\n 文法 哥倫布 文法庫 Unit1  研究所 英文(B) 資訊科技概論\n 114-4  資訊管理導論 演算法 心得： 英文口說  look into (phr.) 深入了解 e.g. The police are looking into the case. see into (phr.) 看穿 e.g. The fortune teller could see into the future. tweic 兩次 三次 take a trip Mokpo dormitory 宿舍 My parents don\u0026rsquo;t have time to keep an eye on me. 父母他們沒有時間管我 Besides playing badminton, I also go running. 除了羽球，我還有跑步 Strict with boys 對男生嚴厲 Jeepney (n.) 吉普尼 Tricycle /ˈtraɪ.sə.kəl/ (n.) 三輪腳踏車 risky blind date (n.) 鄉親 The fortune teller\u0026rsquo;s prediction was very accurate. 算命師的預言非常準確。  明天目標： 英文\n 7000單字 Unit06  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250429/","tags":["日記","2025"],"title":"20250429"},{"categories":["日記"],"contents":"今日目標： 英文\n 文法 哥倫布 文法庫 Unit1  研究所 英文(B) 資訊科技概論\n 114-4  資訊管理導論 演算法 心得： 今天輔導員跟副科沒來， 只好做自己的事， 原本想登入系統打自傳，結果沒注意到大小寫，打錯3次就被鎖起來了， 還要請別人幫忙申請信箱才能解鎖，尷尬~ 之後就繼續看專案程式。 旁邊的新人滿好的， 還會教我怎麼使用影印機，\n有被分派到一個小需求當練習。\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250428/","tags":["日記","2025"],"title":"20250428(一) 登入系統失敗達3次被鎖住~.~"},{"categories":["資料結構"],"contents":"📌定義： 🧠特性：  LIFO(後進先出)  ⏱️ 時間複雜度： ✅ 優點：    ❌ 缺點：  無法依據元素「優先權」來排序或取出  💡 適合用在哪？ 👨‍💻程式： 🧾執行結果： 📚參考文章  ChatGPT  ","permalink":"https://roylintw.github.io/blog/data_structure/linear/3_stack/","tags":["資料結構","Stack"],"title":"資料結構 Stack"},{"categories":["日記"],"contents":"今日目標： 英文\n 7000單字 Unit06(prosection~successive) 文法 哥倫布 文法庫 Unit14.主詞動詞一致(中) Unit15.主詞動詞一致(下)  研究所 英文(B)\n 114-29~31(29~32)  資訊科技概論\n 114-3~5(無)  資訊管理導論\n 114-1(A)、(B)(無)  演算法\n 合併排序法(上)  心得： 今天早上一早6點30分左右就起床了，\n約8:45抵達台企銀，\n到5樓後竟然還有一隻貓坐在沙發上!!!\n原來是台企銀同仁養的哈哈哈。\n後來有人過來帶我到會議室集合，\n早上管制科的負責人發給我們人事資料表，\n因為有些需要等分配完單位才可以填，\n所以把可以填的部分填好後，就一直發呆玩手機\u0026hellip;\n沒想到襄理想要我去寫 COBOL 的組!!!\n想了一會兒，\n我提議還是想寫 Java，\n因此副科會再出考題，看我適不適合待在 Java組。\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B)\n 114-33~35  資訊科技概論\n 114-6~8  資訊管理導論\n 114-2(A)、(B)  演算法\n 合併排序法(下)  ","permalink":"https://roylintw.github.io/blog/diary/20250421/","tags":["日記","2025"],"title":"20250421(一)第一天到台企銀上班"},{"categories":["日記"],"contents":"今日目標： 英文\n 7000單字 Unit06(prosection~successive) 文法 哥倫布 文法庫 Unit14.主詞動詞一致(中) Unit15.主詞動詞一致(下)  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 心得： 今天早上11點副科就請我去考上機考， 然後這次上機考一整個報難QQ， 雖然可以查資料， 但感覺留在 Java組的希望渺茫。\n然後一回家發現房東還幫我們油漆了房間，\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250422/","tags":["日記","2025"],"title":"20250421(二) 可怕的上機考 Lab~"},{"categories":["日記"],"contents":"今日目標： 英文\n 7000單字 Unit06(prosection~successive) 文法 哥倫布 文法庫 Unit14.主詞動詞一致(中) Unit15.主詞動詞一致(下)  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 心得： 今天早上11點副科就請我去考上機考， 然後這次上機考一整個報難QQ， 雖然可以查資料， 但感覺留在 Java組的希望渺茫。\n然後一回家發現房東還幫我們油漆了房間，\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250423/","tags":["日記","2025"],"title":"20250423(三) 上機考 Lab 快寫完了~"},{"categories":["日記"],"contents":"今日目標： 英文\n 7000單字 Unit06(prosection~successive) 文法 哥倫布 文法庫 Unit14.主詞動詞一致(中) Unit15.主詞動詞一致(下)  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 心得： It wasn\u0026rsquo;t a great Thursday, because I have a small cold. It\u0026rsquo;s been a busy week. On Tuesday, I went to the hospital to get my bite guard to prevent me from grinding my teeth while I sleep.\nI\u0026rsquo;m making some notes. Let me take notes.\nlandlord (n.) 房東 Because it had been raining for a long time, the walls of my room got moldy. And then The landlord sent someone to paint the walls. Since the smell was really strong, my girlfriend and I decided to stay at a hotel for the night.\nHow do you spell that word?\nsleepy\ntent\ncamping\nshare stroies catch up = update\npals\nseries\nhorror movie 恐怖片\njoker\nmoisture\nresolutions promise\n我以為\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B) 資訊科技概論 資訊管理導論 演算法 ","permalink":"https://roylintw.github.io/blog/diary/20250424/","tags":["日記","2025"],"title":"20250423(三) 上機考 Lab 快寫完了~"},{"categories":["日記"],"contents":"今日目標： 英文\n 7000單字 Unit06 文法 哥倫布 文法庫 Unit14.主詞動詞一致(中) Unit15.主詞動詞一致(下)  研究所 英文(B)\n資訊科技概論\n 114-3~5  資訊管理導論\n 114-1(A)、(B)  演算法\n 插入排序法  心得： 今天早上決定不去考合庫筆試，\n發現我們家附近有新開一間拉亞，因此早上就買了雞腿米堡跟薯餅，\n下午到ICC囍咖啡義式餐廳忠孝店吃午餐跟看書。\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B)\n資訊科技概論\n 114-6~8  資訊管理導論\n 114-2(A)、(B)  演算法\n 排序法  ","permalink":"https://roylintw.github.io/blog/diary/20250420/","tags":["日記","2025"],"title":"20250420(日)看書"},{"categories":["日記"],"contents":"下載 edge webdriver ：  確認 edge 版本，在網址列輸入edge://version/或edge://settings/help，就會跳出 edge 版本\np.s. 可以先更新至最新版本哦~ 可以知道我的版本是 135.0.3179.85 下載對應版本的 webdriver 到 Microsoft Edge WebDriver 下載區 https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver?form=MA13LH\n找到你目前版本對應的 webdriver 進行下載。\n  註冊 edge webdriver ： 這裡使用 edge webdriver 在專案的相對位置，\n因未來如果在不同人的電腦中使用，就不會有找不到路徑的問題。\nSystem.setProperty(\u0026quot;webdriver.edge.driver\u0026quot;, \u0026quot;edgedriver\\\\msedgedriver.exe\u0026quot;);\n","permalink":"https://roylintw.github.io/blog/fb_ig_autoposter/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/","tags":["日記","2025"],"title":"FB IG 自動新增商品程式"},{"categories":["日記"],"contents":"今日目標： 英文\n 7000單字 Unit06  研究所 英文(B)\n資訊科技概論\n心得： 下週一4/21(一)就要到台企銀報到，\n因此請沛彤跟得榕吃家裡附近的永春葉師傅正宗湖南菜館，\n話說住在永春兩年多，\n每次看到這間，都有種想吃的感覺，\n可是都沒機會進去。\n剛好趁這次機會，體驗看看湖南菜的威力!\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B)\n資訊科技概論\n","permalink":"https://roylintw.github.io/blog/diary/20250418/","tags":["日記","2025"],"title":"20250418(五)永春葉師傅正宗湖南菜館"},{"categories":["演算法"],"contents":"📌定義： 核心思想類似於人們整理撲克牌時的方式：從第二張牌開始，每次從未排序的資料中取出一個元素，插入到前面已排序的資料中的正確位置，直到所有資料都排好序。\n🧠原理：  從第二個元素開始，視為當前要插入的元素 與前面已排序的元素比較，找到合適位置 插入該元素，其他元素向後移動一格 重複上述步驟直到最後一個元素  ⏱️ 時間複雜度：    情況 比較次數 時間複雜度     最佳情況（已排序） O(n) O(n)   最差情況（反序） O(n²) O(n²)   平均情況 O(n²) O(n²)    ✅ 優點：  實作簡單 穩定排序(不改變相同元素的順序) 適合小型陣列或幾乎已經排序好的資料  ❌ 缺點：  效率不高，對於大型資料集不適合  💡 適合用在哪？  適合處理 10~100 筆以內的小資料集，比如：使用者手動輸入的幾筆資料要即時排序\n情境: 一個表單輸入 5 筆數字，按下排序按鈕後即時顯示結果 資料幾乎已經排序好了(近乎有序)\n情境: 每日新增一筆新資料到已排序好的排行榜中。 插入排序只需要將新資料插入適當位置即可，不需重新排序全部。 資料即時進來，需要一筆一筆排序(線上排序)\n插入排序是原地排序（in-place），不需要額外記憶體。\n可用於即時處理每筆輸入的資料。 情境: 實作自動完成提示（autocomplete）功能時，依照使用頻率動態更新排序。  👨‍💻程式： public class InsertionSort {  public static void main(String[] args) {  int[] data = {5, 3, 4, 1, 2};  insertionSort(data);   for (int num : data) {  System.out.print(num + \u0026#34; \u0026#34;);  }  }   public static void insertionSort(int[] arr) {  for (int i = 1; i \u0026lt; arr.length; i++) {  int key = arr[i]; // 要插入的值  int j = i - 1;   // 將比 key 大的元素往後移  while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) {  arr[j + 1] = arr[j];  j--;  }   // 插入 key  arr[j + 1] = key;  }  } } 🧾執行結果： 1 2 3 4 5 📚參考文章  ChatGPT  ","permalink":"https://roylintw.github.io/blog/algorithms/insertionsort/","tags":["演算法","插入排序法"],"title":"🔢 排序演算法 - 插入排序法"},{"categories":["演算法"],"contents":"📌定義： 選擇排序是一種簡單直觀的排序演算法。\n它的基本思想是：每一輪從未排序的元素中選出最小（或最大）的元素，放到已排序區域的最前/後面。\n🧠原理： 假設有一個陣列 [29, 10, 14, 37, 13]，進行升序排序：\n第一次從 [29, 10, 14, 37, 13] 中找最小值是 10 → 與第一個位置 29 交換 → [10, 29, 14, 37, 13]\n第二次從 [29, 14, 37, 13] 找最小值是 13 → 與第二個位置 29 交換 → [10, 13, 14, 37, 29]\n第三次從 [14, 37, 29] 找最小值是 14 → 位置不變 → [10, 13, 14, 37, 29]\n第四次從 [37, 29] 找最小值是 29 → 交換 → [10, 13, 14, 29, 37]\n完成排序。\n⏱️ 時間複雜度：    情況 比較次數 交換次數 時間複雜度     最佳情況 O(n²) O(n) O(n²)   最壞情況 O(n²) O(n) O(n²)   平均情況 O(n²) O(n) O(n²)    ✅ 優點：  思想簡單，實現容易。 不需要額外的記憶體空間（原地排序）。 交換次數少，最多 n-1 次交換（比氣泡排序好）。  ❌ 缺點：  效率差，時間複雜度是 O(n²)，不適合大規模資料。 即使資料已經排序，也會繼續比較。  💡 適合用在哪？ 教學演示排序原理\n資料量小或對效能不敏感時\n想減少寫入動作的場景（因為交換次數較少）\n👨‍💻程式： public class SelectionSortExample {   // Selection Sort 方法：對整數陣列進行升序排序  public static void selectionSort(int[] arr) {  int n = arr.length;   // 外層迴圈控制每一個排序的位置  for (int i = 0; i \u0026lt; n - 1; i++) {  int minIndex = i; // 假設當前 i 是最小值   // 內層迴圈找出從 i+1 到 n-1 中最小值的 index  for (int j = i + 1; j \u0026lt; n; j++) {  if (arr[j] \u0026lt; arr[minIndex]) {  minIndex = j;  }  }   // 如果找到更小值，進行交換  if (minIndex != i) {  int temp = arr[i];  arr[i] = arr[minIndex];  arr[minIndex] = temp;  }  }  }   // 主程式：測試 selection sort  public static void main(String[] args) {  int[] arr = {29, 10, 14, 37, 13};   System.out.println(\u0026#34;排序前：\u0026#34;);  printArray(arr);   selectionSort(arr);   System.out.println(\u0026#34;排序後：\u0026#34;);  printArray(arr);  }   // 輔助方法：印出陣列  public static void printArray(int[] arr) {  for (int num : arr) {  System.out.print(num + \u0026#34; \u0026#34;);  }  System.out.println();  } } 🧾執行結果： 排序前： 29 10 14 37 13 排序後： 10 13 14 29 37 📚參考文章  ChatGPT  ","permalink":"https://roylintw.github.io/blog/algorithms/selectionsort/","tags":["演算法","選擇排序法"],"title":"🔢 排序演算法 - 選擇排序法"},{"categories":["日記"],"contents":"今天早上跟沛彤去西門吃早午餐， 然後看甲狀腺門診， 等到下午1點半去衡觀診所退費\n","permalink":"https://roylintw.github.io/blog/diary/20250416/","tags":["日記","2025"],"title":"20250416(三)西門一日遊"},{"categories":["演算法"],"contents":"氣泡排序法（Bubble Sort）是一種簡單的排序演算法，用於對列表或數組中的元素進行排序。該演算法的基本原理是從列表的開頭開始，兩兩比較相鄰的元素，並在必要時進行交換。這個過程重複多次，直到整個列表有序為止。\n基本原理：  比較和交換：  從列表的開頭開始，依次比較相鄰的兩個元素。 如果前一個元素大於後一個元素，則交換這兩個元素的位置。 這個過程會將較大的元素「冒泡」到列表的末尾，因此稱為「氣泡排序」。   迭代排序：  重複比較和交換的過程，直到列表完全排序。 每次迭代都會將最大的元素放在列表的末尾，因此每次迭代的範圍逐漸減少。   最佳和最差情況：  在最佳情況下，如果列表已經有序，則氣泡排序會很快結束。 在最差情況下，列表逆序排列，則排序所需的比較和交換次數最多。   時間複雜度：  平均和最壞情況時間複雜度為 O(n^2)，其中 n 是列表的長度。 最佳情況時間複雜度為 O(n)（當列表已經有序時）。   優點：  氣泡排序法簡單易懂，實現容易。 在列表已經接近排序的情況下，氣泡排序可以很快完成排序。   缺點：  氣泡排序法效率較低，時間複雜度高於其他一些排序演算法。 在大部分情況下不建議用於大規模數據排序。    氣泡排序法的程式範例： 下面是一個用 Java 實現的氣泡排序法範例：\npublic class BubbleSort {  public static void bubbleSort(int[] array) {  int n = array.length;  boolean swapped;   // 遍歷列表  for (int i = 0; i \u0026lt; n - 1; i++) {  swapped = false;   // 比較相鄰元素  for (int j = 0; j \u0026lt; n - i - 1; j++) {  if (array[j] \u0026gt; array[j + 1]) {  // 交換元素  int temp = array[j];  array[j] = array[j + 1];  array[j + 1] = temp;   // 設定 swapped 為 true 表示有進行交換  swapped = true;  }  }   // 如果這次迭代沒有進行交換，說明列表已經排序完成，可以提前退出  if (!swapped) {  break;  }  }  }   public static void main(String[] args) {  // 定義一個整數數組  int[] array = {64, 34, 25, 12, 22, 11, 90};   // 輸出排序前的數組  System.out.println(\u0026#34;排序前的數組:\u0026#34;);  for (int num : array) {  System.out.print(num + \u0026#34; \u0026#34;);  }  System.out.println();   // 執行氣泡排序  bubbleSort(array);   // 輸出排序後的數組  System.out.println(\u0026#34;排序後的數組:\u0026#34;);  for (int num : array) {  System.out.print(num + \u0026#34; \u0026#34;);  }  } } 參考文章  ChatGPT 【圖解演算法教學】Bubble Sort 的大隊接力賽 入門|介紹|教學|LeetCode|資料結構 Bubble Sort Algorithm - GreeksForGreeks  ","permalink":"https://roylintw.github.io/blog/algorithms/bubblesort/","tags":["演算法","氣泡排序法"],"title":"🔢 排序演算法 - 氣泡排序法"},{"categories":["心得"],"contents":"我是第三篇文章\n","permalink":"https://roylintw.github.io/blog/third-post/","tags":["程式語言","Java"],"title":"第三篇文章"},{"categories":["健康"],"contents":"對眼睛比較友善的網頁顏色通常是較柔和、低對比度的顏色，避免過於刺眼的亮色和高對比度的搭配。以下是一些常見的推薦顏色搭配和原則：\n背景顏色： 使用柔和的淺色背景（如淺灰色或淺米色）會比純白色更能減少眼睛疲勞。白色背景過於刺眼，尤其在長時間觀看時容易感到不適。\n文字顏色： 選擇深色文字（如深灰或黑色）搭配淺色背景。避免使用過於鮮豔或對比過強的顏色（如紅色或黃色），因為這些顏色會讓眼睛感到刺痛。\n暗模式： 如果是長時間使用設備，暗模式（背景黑色或深灰色，文字白色或淺灰色）也是一個不錯的選擇，可以減少眼睛的疲勞和光線對比。\n避免過多的顏色： 除非有特殊設計需求，否則避免網頁使用過多的顏色。過多鮮豔顏色會讓眼睛難以集中注意力。\n調整亮度： 根據環境光線調整亮度，避免在黑暗環境中使用亮色背景，或是在光線強烈的地方使用過於暗沉的顏色。\n這些基本的設計原則有助於減少視覺疲勞，提升用戶的瀏覽體驗。\n本文由 ChatGPT 生成\n","permalink":"https://roylintw.github.io/blog/%E7%B6%B2%E9%A0%81%E7%94%A8%E4%BB%80%E9%BA%BC%E9%A1%8F%E8%89%B2%E5%B0%8D%E7%9C%BC%E7%9D%9B%E6%AF%94%E8%BC%83%E5%A5%BD/","tags":["網頁","眼睛"],"title":"網頁用什麼顏色對眼睛比較好"},{"categories":["證照"],"contents":"Which two code fragments cause a compilation error? (Choose two.) public class Test { \tpublic static final int MIN = 1; \tpublic static void main(String[] args) { \tint x = args.length; \tif(checkLimit(x)) { \tSystem.out.println(\u0026#34;Java SE\u0026#34;); \t} else { \tSystem.out.println(\u0026#34;Java EE\u0026#34;); \t} \t} \tpublic static boolean checkLimit(int x) { \treturn (x \u0026gt;= MIN) ? true : false; \t} } And given the commands:\njavac Test.java\rjava Test 1 Which two code fragments cause a compilation error? (Choose two.) A. float flt = 100.00F; B. float flt = (float) 1_11.00; C. Float flt = 100.00; D. double y1 = 203.22;float flt = y1; E. int y2 = 100;float flt = (float) y2 ;  題解 字串\u0026quot;1\u0026quot;傳入後，得到長度 1，\n進入 checkLimit( )，x 等於 MIN，得到 true，\n進入第一個 if敘述，答案是 \u0026ldquo;Java SE\u0026rdquo;\n","permalink":"https://roylintw.github.io/blog/oca/oca_36/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第36題 基本型態轉換"},{"categories":["Java"],"contents":"參考連結 基本資料型態\nJava 原始資料型態預設值 primitive data type default value\n","permalink":"https://roylintw.github.io/blog/java/primitive_data_types/","tags":["Java","觀念"],"title":"【Java】基本資料型態 預設值"},{"categories":["證照"],"contents":"題目 Given this code for the classes MyException and Test: public class MyException extends RuntimeException {} public class Test { \tpublic static void main(String[] args) { \ttry { \tmethod1(); \t} catch (MyException ee) { \tSystem.out.println(\u0026#34;A\u0026#34;); \t} \t} \t\tpublic static void method1() { //line n1 \ttry { \tthrow 3 \u0026gt; 10 ? new MyException() : new IOException(); \t} catch (IOException e) { \tSystem.out.println(\u0026#34;I\u0026#34;); \t} catch (Exception e) { \tSystem.out.println(\u0026#34;B\u0026#34;); \t} \t} } What is the result? A. A B. AB C. A compile time error occurs at line n1. D. B E. I  題解 首先呼叫 method1()，\n進入 try區塊，\n因為 3 \u0026lt; 10，拋出 new IOException()，\n接下來，進入到第一個 catch區塊，印出 \u0026ldquo;I\u0026rdquo;，答案是 (E)\n","permalink":"https://roylintw.github.io/blog/oca/oca_196/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第196題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which is the result? A. Compilation fails in the Employee class. B. null : 0 : 0 Jack : 50 : 0 Chloe : 40 : 5000 C. null : 0 : 0 Jack : 50 : 2000 Chloe : 40 : 5000 D. Compilation fails in the Test class. E. Both the Employee class and the Test class fail to compile.  題解 只要有新增一個有參數的建構方法，那空的建構方法也要自己設定。\n","permalink":"https://roylintw.github.io/blog/oca/oca_introduction/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 1Z0-808 介紹"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \ttry { \tint num = 10; \tint div = 0; \tint ans = num/div; \t} catch (ArithmeticException ae) { \tans = 0; \t} catch (Exception e) { \tSystem.out.println(\u0026#34;Invalid calculation\u0026#34;); \t} \tSystem.out.println(\u0026#34;Answer = \u0026#34; + ans); \t} What is the result? A. Answer = 0 B. Invalid calculation C. Compilation fails only at line n1. D. Compilation fails only at line n2. E. Compilation fails at line n1 and line2.  題解 一開始大家可能以為照題目的意思，\n10/0 會報錯 ArithmeticException，\n然後進入第一個 catch區塊， ans = 0，\n可是一開始宣告的區域變數 ans只有在 try區塊看的到，在其他區塊無法看到 ans，\n因此抱錯 ans cannot be resolved to a variable， 答案就是(E)\n","permalink":"https://roylintw.github.io/blog/oca/oca_197/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第197題"},{"categories":["證照"],"contents":"Examine the given definitions: Which statement is true about the implementation of Object-Oriented Programming concepts in the given code ? A. Polymorphism, abstraction, and encapsulation are implemented. B. Only polymorphism and inheritance are implemented. C. Polymorphism, inheritance, and abstraction are implemented. D. Only inheritance and encapsulation are implemented.  題解 Playable p有去操縱 game物件，所以有用到\u0026quot;多型\u0026quot;\n有把屬性變成 private，並只能用 getxx方法取出，所以有用到\u0026quot;封裝\u0026quot;\n","permalink":"https://roylintw.github.io/blog/oca/oca_198/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第198題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tList\u0026lt;String\u0026gt; lst = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;); \tIterator\u0026lt;String\u0026gt; itr = lst.iterator(); \twhile(itr.hasNext()) { \tString e = itr.next(); \tif(e == \u0026#34;C\u0026#34;) { \tbreak; \t} \telse {  continue; \tSystem.out.print(e); \t} \t} \t} Which action enables it to print AB? A. Comment lines 18 to 21. B. Comment line 20. C. Comment line 19. D. Comment line 16.  題解 因為 System.out.print(e)前面有 continue，\n因此無論是字串A、B、D進入 else區塊，\n都不會執行到 System.out.print(e)，\n只要把 20行註解，就可以印出 AB，答案是(C)\n","permalink":"https://roylintw.github.io/blog/oca/oca_199/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第199題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which is the result? A. Compilation fails in the Employee class. B. null : 0 : 0 Jack : 50 : 0 Chloe : 40 : 5000 C. null : 0 : 0 Jack : 50 : 2000 Chloe : 40 : 5000 D. Compilation fails in the Test class. E. Both the Employee class and the Test class fail to compile.  題解 只要有新增一個有參數的建構方法，那空的建構方法也要自己設定。\n","permalink":"https://roylintw.github.io/blog/oca/oca_1/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第1題 建構方法"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which code fragment, when inserted at line 9, enables the code to print true? A. String str2 = str1; B. String str2 = new String(str1); C. String str2 = sb1. toString(); D. String str2 = \u0026ldquo;Duke\u0026rdquo;;  題解 ==比較的是地址值，\n如果第 10行要印出 true的話，\nstr1 跟 str2的地址值要相同，\nstring str2 = str1，就是 str2變數指向 str1的物件，\n兩個變數共用同一個物件，地址值相同，\n答案是(A)\n","permalink":"https://roylintw.github.io/blog/oca/oca_200/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第200題"},{"categories":["證照"],"contents":"Given: public class Test { \tpublic static final int MIN = 1; \tpublic static void main(String[] args) { \tint x = args.length; \tif(checkLimit(x)) { \tSystem.out.println(\u0026#34;Java SE\u0026#34;); \t} else { \tSystem.out.println(\u0026#34;Java EE\u0026#34;); \t} \t} \tpublic static boolean checkLimit(int x) { \treturn (x \u0026gt;= MIN) ? true : false; \t} } And given the commands:\njavac Test.java\rjava Test 1 Which is the result? A. Java SE B. Java EE C. Compilation fails at line n1. D. A NullPointerException is thrown at runtime.  題解 字串\u0026quot;1\u0026quot;傳入後，得到長度 1，\n進入 checkLimit( )，x 等於 MIN，得到 true，\n進入第一個 if敘述，答案是 \u0026ldquo;Java SE\u0026rdquo;\n","permalink":"https://roylintw.github.io/blog/oca/oca_2/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第2題 三元運算式"},{"categories":null,"contents":"一級 system.out.print(\u0026#34;hello\u0026#34;) ","permalink":"https://roylintw.github.io/blog/test2/","tags":null,"title":""}]