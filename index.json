[{"categories":["日記"],"contents":"今日目標： 英文\n 7000單字 Unit06 文法 哥倫布 文法庫 Unit14.主詞動詞一致(中) Unit15.主詞動詞一致(下)  研究所 英文(B)\n資訊科技概論\n心得： 今天早上決定不去考合庫筆試，\n發現我們家附近有新開一間拉亞，因此早上就買了雞腿米堡跟薯餅，\n下午到ICC囍咖啡義式餐廳忠孝店吃午餐跟看書。\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B)\n資訊科技概論\n","permalink":"https://roylintw.github.io/blog/diary/20250420/","tags":["日記","2025"],"title":"20250420(日)看書"},{"categories":["日記"],"contents":"下載 edge webdriver ：  確認 edge 版本，在網址列輸入edge://version/或edge://settings/help，就會跳出 edge 版本\np.s. 可以先更新至最新版本哦~ 可以知道我的版本是 135.0.3179.85 下載對應版本的 webdriver 到 Microsoft Edge WebDriver 下載區 https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver?form=MA13LH\n找到你目前版本對應的 webdriver 進行下載。\n  註冊 edge webdriver ： 這裡使用 edge webdriver 在專案的相對位置，\n因未來如果在不同人的電腦中使用，就不會有找不到路徑的問題。\nSystem.setProperty(\u0026quot;webdriver.edge.driver\u0026quot;, \u0026quot;edgedriver\\\\msedgedriver.exe\u0026quot;);\n","permalink":"https://roylintw.github.io/blog/fb_ig_autoposter/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/","tags":["日記","2025"],"title":"FB IG 自動新增商品程式"},{"categories":["日記"],"contents":"今日目標： 英文\n 7000單字 Unit06  研究所 英文(B)\n資訊科技概論\n心得： 下週一4/21(一)就要到台企銀報到，\n因此請沛彤跟得榕吃家裡附近的永春葉師傅正宗湖南菜館，\n話說住在永春兩年多，\n每次看到這間，都有種想吃的感覺，\n可是都沒機會進去。\n剛好趁這次機會，體驗看看湖南菜的威力!\n明天目標： 英文\n 7000單字 Unit06  研究所 英文(B)\n資訊科技概論\n","permalink":"https://roylintw.github.io/blog/diary/20250418/","tags":["日記","2025"],"title":"20250418(五)永春葉師傅正宗湖南菜館"},{"categories":["演算法"],"contents":"📌定義： 選擇排序是一種簡單直觀的排序演算法。\n它的基本思想是：每一輪從未排序的元素中選出最小（或最大）的元素，放到已排序區域的最前/後面。\n🧠原理： 假設有一個陣列 [29, 10, 14, 37, 13]，進行升序排序：\n第一次從 [29, 10, 14, 37, 13] 中找最小值是 10 → 與第一個位置 29 交換 → [10, 29, 14, 37, 13]\n第二次從 [29, 14, 37, 13] 找最小值是 13 → 與第二個位置 29 交換 → [10, 13, 14, 37, 29]\n第三次從 [14, 37, 29] 找最小值是 14 → 位置不變 → [10, 13, 14, 37, 29]\n第四次從 [37, 29] 找最小值是 29 → 交換 → [10, 13, 14, 29, 37]\n完成排序。\n⏱️ 時間複雜度：    情況 比較次數 交換次數 時間複雜度     最佳情況 O(n²) O(n) O(n²)   最壞情況 O(n²) O(n) O(n²)   平均情況 O(n²) O(n) O(n²)    ✅ 優點：  思想簡單，實現容易。 不需要額外的記憶體空間（原地排序）。 交換次數少，最多 n-1 次交換（比氣泡排序好）。  ❌ 缺點：  效率差，時間複雜度是 O(n²)，不適合大規模資料。 即使資料已經排序，也會繼續比較。  💡 適合用在哪？ 教學演示排序原理\n資料量小或對效能不敏感時\n想減少寫入動作的場景（因為交換次數較少）\n👨‍💻程式： public class SelectionSortExample {   // Selection Sort 方法：對整數陣列進行升序排序  public static void selectionSort(int[] arr) {  int n = arr.length;   // 外層迴圈控制每一個排序的位置  for (int i = 0; i \u0026lt; n - 1; i++) {  int minIndex = i; // 假設當前 i 是最小值   // 內層迴圈找出從 i+1 到 n-1 中最小值的 index  for (int j = i + 1; j \u0026lt; n; j++) {  if (arr[j] \u0026lt; arr[minIndex]) {  minIndex = j;  }  }   // 如果找到更小值，進行交換  if (minIndex != i) {  int temp = arr[i];  arr[i] = arr[minIndex];  arr[minIndex] = temp;  }  }  }   // 主程式：測試 selection sort  public static void main(String[] args) {  int[] arr = {29, 10, 14, 37, 13};   System.out.println(\u0026#34;排序前：\u0026#34;);  printArray(arr);   selectionSort(arr);   System.out.println(\u0026#34;排序後：\u0026#34;);  printArray(arr);  }   // 輔助方法：印出陣列  public static void printArray(int[] arr) {  for (int num : arr) {  System.out.print(num + \u0026#34; \u0026#34;);  }  System.out.println();  } } 🧾執行結果： 排序前： 29 10 14 37 13 排序後： 10 13 14 29 37 📚參考文章  ChatGPT  ","permalink":"https://roylintw.github.io/blog/algorithms/insertionsort/","tags":["演算法","插入排序法"],"title":"🔢 排序演算法 - 插入排序法"},{"categories":["演算法"],"contents":"📌定義： 選擇排序是一種簡單直觀的排序演算法。\n它的基本思想是：每一輪從未排序的元素中選出最小（或最大）的元素，放到已排序區域的最前/後面。\n🧠原理： 假設有一個陣列 [29, 10, 14, 37, 13]，進行升序排序：\n第一次從 [29, 10, 14, 37, 13] 中找最小值是 10 → 與第一個位置 29 交換 → [10, 29, 14, 37, 13]\n第二次從 [29, 14, 37, 13] 找最小值是 13 → 與第二個位置 29 交換 → [10, 13, 14, 37, 29]\n第三次從 [14, 37, 29] 找最小值是 14 → 位置不變 → [10, 13, 14, 37, 29]\n第四次從 [37, 29] 找最小值是 29 → 交換 → [10, 13, 14, 29, 37]\n完成排序。\n⏱️ 時間複雜度：    情況 比較次數 交換次數 時間複雜度     最佳情況 O(n²) O(n) O(n²)   最壞情況 O(n²) O(n) O(n²)   平均情況 O(n²) O(n) O(n²)    ✅ 優點：  思想簡單，實現容易。 不需要額外的記憶體空間（原地排序）。 交換次數少，最多 n-1 次交換（比氣泡排序好）。  ❌ 缺點：  效率差，時間複雜度是 O(n²)，不適合大規模資料。 即使資料已經排序，也會繼續比較。  💡 適合用在哪？ 教學演示排序原理\n資料量小或對效能不敏感時\n想減少寫入動作的場景（因為交換次數較少）\n👨‍💻程式： public class SelectionSortExample {   // Selection Sort 方法：對整數陣列進行升序排序  public static void selectionSort(int[] arr) {  int n = arr.length;   // 外層迴圈控制每一個排序的位置  for (int i = 0; i \u0026lt; n - 1; i++) {  int minIndex = i; // 假設當前 i 是最小值   // 內層迴圈找出從 i+1 到 n-1 中最小值的 index  for (int j = i + 1; j \u0026lt; n; j++) {  if (arr[j] \u0026lt; arr[minIndex]) {  minIndex = j;  }  }   // 如果找到更小值，進行交換  if (minIndex != i) {  int temp = arr[i];  arr[i] = arr[minIndex];  arr[minIndex] = temp;  }  }  }   // 主程式：測試 selection sort  public static void main(String[] args) {  int[] arr = {29, 10, 14, 37, 13};   System.out.println(\u0026#34;排序前：\u0026#34;);  printArray(arr);   selectionSort(arr);   System.out.println(\u0026#34;排序後：\u0026#34;);  printArray(arr);  }   // 輔助方法：印出陣列  public static void printArray(int[] arr) {  for (int num : arr) {  System.out.print(num + \u0026#34; \u0026#34;);  }  System.out.println();  } } 🧾執行結果： 排序前： 29 10 14 37 13 排序後： 10 13 14 29 37 📚參考文章  ChatGPT  ","permalink":"https://roylintw.github.io/blog/algorithms/selectionsort/","tags":["演算法","選擇排序法"],"title":"🔢 排序演算法 - 選擇排序法"},{"categories":["日記"],"contents":"今天早上跟沛彤去西門吃早午餐， 然後看甲狀腺門診， 等到下午1點半去衡觀診所退費\n","permalink":"https://roylintw.github.io/blog/diary/20250416/","tags":["日記","2025"],"title":"20250416(三)西門一日遊"},{"categories":["演算法"],"contents":"氣泡排序法（Bubble Sort）是一種簡單的排序演算法，用於對列表或數組中的元素進行排序。該演算法的基本原理是從列表的開頭開始，兩兩比較相鄰的元素，並在必要時進行交換。這個過程重複多次，直到整個列表有序為止。\n基本原理：  比較和交換：  從列表的開頭開始，依次比較相鄰的兩個元素。 如果前一個元素大於後一個元素，則交換這兩個元素的位置。 這個過程會將較大的元素「冒泡」到列表的末尾，因此稱為「氣泡排序」。   迭代排序：  重複比較和交換的過程，直到列表完全排序。 每次迭代都會將最大的元素放在列表的末尾，因此每次迭代的範圍逐漸減少。   最佳和最差情況：  在最佳情況下，如果列表已經有序，則氣泡排序會很快結束。 在最差情況下，列表逆序排列，則排序所需的比較和交換次數最多。   時間複雜度：  平均和最壞情況時間複雜度為 O(n^2)，其中 n 是列表的長度。 最佳情況時間複雜度為 O(n)（當列表已經有序時）。   優點：  氣泡排序法簡單易懂，實現容易。 在列表已經接近排序的情況下，氣泡排序可以很快完成排序。   缺點：  氣泡排序法效率較低，時間複雜度高於其他一些排序演算法。 在大部分情況下不建議用於大規模數據排序。    氣泡排序法的程式範例： 下面是一個用 Java 實現的氣泡排序法範例：\npublic class BubbleSort {  public static void bubbleSort(int[] array) {  int n = array.length;  boolean swapped;   // 遍歷列表  for (int i = 0; i \u0026lt; n - 1; i++) {  swapped = false;   // 比較相鄰元素  for (int j = 0; j \u0026lt; n - i - 1; j++) {  if (array[j] \u0026gt; array[j + 1]) {  // 交換元素  int temp = array[j];  array[j] = array[j + 1];  array[j + 1] = temp;   // 設定 swapped 為 true 表示有進行交換  swapped = true;  }  }   // 如果這次迭代沒有進行交換，說明列表已經排序完成，可以提前退出  if (!swapped) {  break;  }  }  }   public static void main(String[] args) {  // 定義一個整數數組  int[] array = {64, 34, 25, 12, 22, 11, 90};   // 輸出排序前的數組  System.out.println(\u0026#34;排序前的數組:\u0026#34;);  for (int num : array) {  System.out.print(num + \u0026#34; \u0026#34;);  }  System.out.println();   // 執行氣泡排序  bubbleSort(array);   // 輸出排序後的數組  System.out.println(\u0026#34;排序後的數組:\u0026#34;);  for (int num : array) {  System.out.print(num + \u0026#34; \u0026#34;);  }  } } 參考文章  ChatGPT 【圖解演算法教學】Bubble Sort 的大隊接力賽 入門|介紹|教學|LeetCode|資料結構 Bubble Sort Algorithm - GreeksForGreeks  ","permalink":"https://roylintw.github.io/blog/algorithms/bubblesort/","tags":["演算法","氣泡排序法"],"title":"🔢 排序演算法 - 氣泡排序法"},{"categories":["心得"],"contents":"我是第三篇文章\n","permalink":"https://roylintw.github.io/blog/third-post/","tags":["程式語言","Java"],"title":"第三篇文章"},{"categories":["健康"],"contents":"對眼睛比較友善的網頁顏色通常是較柔和、低對比度的顏色，避免過於刺眼的亮色和高對比度的搭配。以下是一些常見的推薦顏色搭配和原則：\n背景顏色： 使用柔和的淺色背景（如淺灰色或淺米色）會比純白色更能減少眼睛疲勞。白色背景過於刺眼，尤其在長時間觀看時容易感到不適。\n文字顏色： 選擇深色文字（如深灰或黑色）搭配淺色背景。避免使用過於鮮豔或對比過強的顏色（如紅色或黃色），因為這些顏色會讓眼睛感到刺痛。\n暗模式： 如果是長時間使用設備，暗模式（背景黑色或深灰色，文字白色或淺灰色）也是一個不錯的選擇，可以減少眼睛的疲勞和光線對比。\n避免過多的顏色： 除非有特殊設計需求，否則避免網頁使用過多的顏色。過多鮮豔顏色會讓眼睛難以集中注意力。\n調整亮度： 根據環境光線調整亮度，避免在黑暗環境中使用亮色背景，或是在光線強烈的地方使用過於暗沉的顏色。\n這些基本的設計原則有助於減少視覺疲勞，提升用戶的瀏覽體驗。\n本文由 ChatGPT 生成\n","permalink":"https://roylintw.github.io/blog/%E7%B6%B2%E9%A0%81%E7%94%A8%E4%BB%80%E9%BA%BC%E9%A1%8F%E8%89%B2%E5%B0%8D%E7%9C%BC%E7%9D%9B%E6%AF%94%E8%BC%83%E5%A5%BD/","tags":["網頁","眼睛"],"title":"網頁用什麼顏色對眼睛比較好"},{"categories":["證照"],"contents":"Which two code fragments cause a compilation error? (Choose two.) public class Test { \tpublic static final int MIN = 1; \tpublic static void main(String[] args) { \tint x = args.length; \tif(checkLimit(x)) { \tSystem.out.println(\u0026#34;Java SE\u0026#34;); \t} else { \tSystem.out.println(\u0026#34;Java EE\u0026#34;); \t} \t} \tpublic static boolean checkLimit(int x) { \treturn (x \u0026gt;= MIN) ? true : false; \t} } And given the commands:\njavac Test.java\rjava Test 1 Which two code fragments cause a compilation error? (Choose two.) A. float flt = 100.00F; B. float flt = (float) 1_11.00; C. Float flt = 100.00; D. double y1 = 203.22;float flt = y1; E. int y2 = 100;float flt = (float) y2 ;  題解 字串\u0026quot;1\u0026quot;傳入後，得到長度 1，\n進入 checkLimit( )，x 等於 MIN，得到 true，\n進入第一個 if敘述，答案是 \u0026ldquo;Java SE\u0026rdquo;\n","permalink":"https://roylintw.github.io/blog/oca/oca_36/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第36題 基本型態轉換"},{"categories":["Java"],"contents":"參考連結 基本資料型態\nJava 原始資料型態預設值 primitive data type default value\n","permalink":"https://roylintw.github.io/blog/java/primitive_data_types/","tags":["Java","觀念"],"title":"【Java】基本資料型態 預設值"},{"categories":["證照"],"contents":"題目 Given this code for the classes MyException and Test: public class MyException extends RuntimeException {} public class Test { \tpublic static void main(String[] args) { \ttry { \tmethod1(); \t} catch (MyException ee) { \tSystem.out.println(\u0026#34;A\u0026#34;); \t} \t} \t\tpublic static void method1() { //line n1 \ttry { \tthrow 3 \u0026gt; 10 ? new MyException() : new IOException(); \t} catch (IOException e) { \tSystem.out.println(\u0026#34;I\u0026#34;); \t} catch (Exception e) { \tSystem.out.println(\u0026#34;B\u0026#34;); \t} \t} } What is the result? A. A B. AB C. A compile time error occurs at line n1. D. B E. I  題解 首先呼叫 method1()，\n進入 try區塊，\n因為 3 \u0026lt; 10，拋出 new IOException()，\n接下來，進入到第一個 catch區塊，印出 \u0026ldquo;I\u0026rdquo;，答案是 (E)\n","permalink":"https://roylintw.github.io/blog/oca/oca_196/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第196題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which is the result? A. Compilation fails in the Employee class. B. null : 0 : 0 Jack : 50 : 0 Chloe : 40 : 5000 C. null : 0 : 0 Jack : 50 : 2000 Chloe : 40 : 5000 D. Compilation fails in the Test class. E. Both the Employee class and the Test class fail to compile.  題解 只要有新增一個有參數的建構方法，那空的建構方法也要自己設定。\n","permalink":"https://roylintw.github.io/blog/oca/oca_introduction/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 1Z0-808 介紹"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \ttry { \tint num = 10; \tint div = 0; \tint ans = num/div; \t} catch (ArithmeticException ae) { \tans = 0; \t} catch (Exception e) { \tSystem.out.println(\u0026#34;Invalid calculation\u0026#34;); \t} \tSystem.out.println(\u0026#34;Answer = \u0026#34; + ans); \t} What is the result? A. Answer = 0 B. Invalid calculation C. Compilation fails only at line n1. D. Compilation fails only at line n2. E. Compilation fails at line n1 and line2.  題解 一開始大家可能以為照題目的意思，\n10/0 會報錯 ArithmeticException，\n然後進入第一個 catch區塊， ans = 0，\n可是一開始宣告的區域變數 ans只有在 try區塊看的到，在其他區塊無法看到 ans，\n因此抱錯 ans cannot be resolved to a variable， 答案就是(E)\n","permalink":"https://roylintw.github.io/blog/oca/oca_197/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第197題"},{"categories":["證照"],"contents":"Examine the given definitions: Which statement is true about the implementation of Object-Oriented Programming concepts in the given code ? A. Polymorphism, abstraction, and encapsulation are implemented. B. Only polymorphism and inheritance are implemented. C. Polymorphism, inheritance, and abstraction are implemented. D. Only inheritance and encapsulation are implemented.  題解 Playable p有去操縱 game物件，所以有用到\u0026quot;多型\u0026quot;\n有把屬性變成 private，並只能用 getxx方法取出，所以有用到\u0026quot;封裝\u0026quot;\n","permalink":"https://roylintw.github.io/blog/oca/oca_198/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第198題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tList\u0026lt;String\u0026gt; lst = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;); \tIterator\u0026lt;String\u0026gt; itr = lst.iterator(); \twhile(itr.hasNext()) { \tString e = itr.next(); \tif(e == \u0026#34;C\u0026#34;) { \tbreak; \t} \telse {  continue; \tSystem.out.print(e); \t} \t} \t} Which action enables it to print AB? A. Comment lines 18 to 21. B. Comment line 20. C. Comment line 19. D. Comment line 16.  題解 因為 System.out.print(e)前面有 continue，\n因此無論是字串A、B、D進入 else區塊，\n都不會執行到 System.out.print(e)，\n只要把 20行註解，就可以印出 AB，答案是(C)\n","permalink":"https://roylintw.github.io/blog/oca/oca_199/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第199題"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which is the result? A. Compilation fails in the Employee class. B. null : 0 : 0 Jack : 50 : 0 Chloe : 40 : 5000 C. null : 0 : 0 Jack : 50 : 2000 Chloe : 40 : 5000 D. Compilation fails in the Test class. E. Both the Employee class and the Test class fail to compile.  題解 只要有新增一個有參數的建構方法，那空的建構方法也要自己設定。\n","permalink":"https://roylintw.github.io/blog/oca/oca_1/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第1題 建構方法"},{"categories":["證照"],"contents":"Given the code fragment: public static void main(String[] args) { \tStringBuilder sb1 = new StringBuilder(\u0026#34;Duke\u0026#34;); \tString str1 = sb1.toString(); \tString str2 = str1; \tSystem.out.println(str1 == str2); \t} Which code fragment, when inserted at line 9, enables the code to print true? A. String str2 = str1; B. String str2 = new String(str1); C. String str2 = sb1. toString(); D. String str2 = \u0026ldquo;Duke\u0026rdquo;;  題解 ==比較的是地址值，\n如果第 10行要印出 true的話，\nstr1 跟 str2的地址值要相同，\nstring str2 = str1，就是 str2變數指向 str1的物件，\n兩個變數共用同一個物件，地址值相同，\n答案是(A)\n","permalink":"https://roylintw.github.io/blog/oca/oca_200/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第200題"},{"categories":["證照"],"contents":"Given: public class Test { \tpublic static final int MIN = 1; \tpublic static void main(String[] args) { \tint x = args.length; \tif(checkLimit(x)) { \tSystem.out.println(\u0026#34;Java SE\u0026#34;); \t} else { \tSystem.out.println(\u0026#34;Java EE\u0026#34;); \t} \t} \tpublic static boolean checkLimit(int x) { \treturn (x \u0026gt;= MIN) ? true : false; \t} } And given the commands:\njavac Test.java\rjava Test 1 Which is the result? A. Java SE B. Java EE C. Compilation fails at line n1. D. A NullPointerException is thrown at runtime.  題解 字串\u0026quot;1\u0026quot;傳入後，得到長度 1，\n進入 checkLimit( )，x 等於 MIN，得到 true，\n進入第一個 if敘述，答案是 \u0026ldquo;Java SE\u0026rdquo;\n","permalink":"https://roylintw.github.io/blog/oca/oca_2/","tags":["證照","Java","1Z0-808","OCAJP"],"title":"OCA 第2題 三元運算式"},{"categories":null,"contents":"一級 system.out.print(\u0026#34;hello\u0026#34;) ","permalink":"https://roylintw.github.io/blog/test2/","tags":null,"title":""}]