<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>氣泡排序法 on 小書僮</title>
    <link>https://roylintw.github.io/tags/%E6%B0%A3%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95/</link>
    <description>Recent content in 氣泡排序法 on 小書僮</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 28 Mar 2025 10:15:35 +0800</lastBuildDate><atom:link href="https://roylintw.github.io/tags/%E6%B0%A3%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>🔢 排序演算法 - 氣泡排序法</title>
      <link>https://roylintw.github.io/blog/algorithms/bubblesort/</link>
      <pubDate>Fri, 28 Mar 2025 10:15:35 +0800</pubDate>
      
      <guid>https://roylintw.github.io/blog/algorithms/bubblesort/</guid>
      <description>氣泡排序法（Bubble Sort）是一種簡單的排序演算法，用於對列表或數組中的元素進行排序。該演算法的基本原理是從列表的開頭開始，兩兩比較相鄰的元素，並在必要時進行交換。這個過程重複多次，直到整個列表有序為止。
基本原理：  比較和交換：  從列表的開頭開始，依次比較相鄰的兩個元素。 如果前一個元素大於後一個元素，則交換這兩個元素的位置。 這個過程會將較大的元素「冒泡」到列表的末尾，因此稱為「氣泡排序」。   迭代排序：  重複比較和交換的過程，直到列表完全排序。 每次迭代都會將最大的元素放在列表的末尾，因此每次迭代的範圍逐漸減少。   最佳和最差情況：  在最佳情況下，如果列表已經有序，則氣泡排序會很快結束。 在最差情況下，列表逆序排列，則排序所需的比較和交換次數最多。   時間複雜度：  平均和最壞情況時間複雜度為 O(n^2)，其中 n 是列表的長度。 最佳情況時間複雜度為 O(n)（當列表已經有序時）。   優點：  氣泡排序法簡單易懂，實現容易。 在列表已經接近排序的情況下，氣泡排序可以很快完成排序。   缺點：  氣泡排序法效率較低，時間複雜度高於其他一些排序演算法。 在大部分情況下不建議用於大規模數據排序。    氣泡排序法的程式範例： 下面是一個用 Java 實現的氣泡排序法範例：</description>
    </item>
    
  </channel>
</rss>
